{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Equipo/source/Tgsc-Proyectos/youManager-web/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders, isNode, URLBuilder } from \"@azure/core-http\";\nimport { DevelopmentConnectionString, HeaderConstants, URLConstants } from \"./constants\";\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JS SDKs\n *\n * When customers pass a URL string into XxxClient classes constructor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XxxClient constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" instead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `containerClient.getBlobClient(blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @param url -\n */\n\nexport function escapeURLPath(url) {\n  const urlParsed = URLBuilder.parse(url);\n  let path = urlParsed.getPath();\n  path = path || \"/\";\n  path = escape(path);\n  urlParsed.setPath(path);\n  return urlParsed.toString();\n}\n\nfunction getProxyUriFromDevConnString(connectionString) {\n  // Development Connection String\n  // https://docs.microsoft.com/en-us/azure/storage/common/storage-configure-connection-string#connect-to-the-emulator-account-using-the-well-known-account-name-and-key\n  let proxyUri = \"\";\n\n  if (connectionString.search(\"DevelopmentStorageProxyUri=\") !== -1) {\n    // CONNECTION_STRING=UseDevelopmentStorage=true;DevelopmentStorageProxyUri=http://myProxyUri\n    const matchCredentials = connectionString.split(\";\");\n\n    for (const element of matchCredentials) {\n      if (element.trim().startsWith(\"DevelopmentStorageProxyUri=\")) {\n        proxyUri = element.trim().match(\"DevelopmentStorageProxyUri=(.*)\")[1];\n      }\n    }\n  }\n\n  return proxyUri;\n}\n\nexport function getValueInConnString(connectionString, argument) {\n  const elements = connectionString.split(\";\");\n\n  for (const element of elements) {\n    if (element.trim().startsWith(argument)) {\n      return element.trim().match(argument + \"=(.*)\")[1];\n    }\n  }\n\n  return \"\";\n}\n/**\n * Extracts the parts of an Azure Storage account connection string.\n *\n * @param connectionString - Connection string.\n * @returns String key value pairs of the storage account's url and credentials.\n */\n\nexport function extractConnectionStringParts(connectionString) {\n  let proxyUri = \"\";\n\n  if (connectionString.startsWith(\"UseDevelopmentStorage=true\")) {\n    // Development connection string\n    proxyUri = getProxyUriFromDevConnString(connectionString);\n    connectionString = DevelopmentConnectionString;\n  } // Matching BlobEndpoint in the Account connection string\n\n\n  let blobEndpoint = getValueInConnString(connectionString, \"BlobEndpoint\"); // Slicing off '/' at the end if exists\n  // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)\n\n  blobEndpoint = blobEndpoint.endsWith(\"/\") ? blobEndpoint.slice(0, -1) : blobEndpoint;\n\n  if (connectionString.search(\"DefaultEndpointsProtocol=\") !== -1 && connectionString.search(\"AccountKey=\") !== -1) {\n    // Account connection string\n    let defaultEndpointsProtocol = \"\";\n    let accountName = \"\";\n    let accountKey = Buffer.from(\"accountKey\", \"base64\");\n    let endpointSuffix = \"\"; // Get account name and key\n\n    accountName = getValueInConnString(connectionString, \"AccountName\");\n    accountKey = Buffer.from(getValueInConnString(connectionString, \"AccountKey\"), \"base64\");\n\n    if (!blobEndpoint) {\n      // BlobEndpoint is not present in the Account connection string\n      // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`\n      defaultEndpointsProtocol = getValueInConnString(connectionString, \"DefaultEndpointsProtocol\");\n      const protocol = defaultEndpointsProtocol.toLowerCase();\n\n      if (protocol !== \"https\" && protocol !== \"http\") {\n        throw new Error(\"Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'\");\n      }\n\n      endpointSuffix = getValueInConnString(connectionString, \"EndpointSuffix\");\n\n      if (!endpointSuffix) {\n        throw new Error(\"Invalid EndpointSuffix in the provided Connection String\");\n      }\n\n      blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n    }\n\n    if (!accountName) {\n      throw new Error(\"Invalid AccountName in the provided Connection String\");\n    } else if (accountKey.length === 0) {\n      throw new Error(\"Invalid AccountKey in the provided Connection String\");\n    }\n\n    return {\n      kind: \"AccountConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountKey,\n      proxyUri\n    };\n  } else {\n    // SAS connection string\n    const accountSas = getValueInConnString(connectionString, \"SharedAccessSignature\");\n    const accountName = getAccountNameFromUrl(blobEndpoint);\n\n    if (!blobEndpoint) {\n      throw new Error(\"Invalid BlobEndpoint in the provided SAS Connection String\");\n    } else if (!accountSas) {\n      throw new Error(\"Invalid SharedAccessSignature in the provided SAS Connection String\");\n    }\n\n    return {\n      kind: \"SASConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountSas\n    };\n  }\n}\n/**\n * Internal escape method implemented Strategy Two mentioned in escapeURL() description.\n *\n * @param text -\n */\n\nfunction escape(text) {\n  return encodeURIComponent(text).replace(/%2F/g, \"/\") // Don't escape for \"/\"\n  .replace(/'/g, \"%27\") // Escape for \"'\"\n  .replace(/\\+/g, \"%20\").replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @param url - Source URL string\n * @param name - String to be appended to URL\n * @returns An updated URL string\n */\n\n\nexport function appendToURLPath(url, name) {\n  const urlParsed = URLBuilder.parse(url);\n  let path = urlParsed.getPath();\n  path = path ? path.endsWith(\"/\") ? `${path}${name}` : `${path}/${name}` : name;\n  urlParsed.setPath(path);\n  return urlParsed.toString();\n}\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @param url - Source URL string\n * @param name - Parameter name\n * @param value - Parameter value\n * @returns An updated URL string\n */\n\nexport function setURLParameter(url, name, value) {\n  const urlParsed = URLBuilder.parse(url);\n  urlParsed.setQueryParameter(name, value);\n  return urlParsed.toString();\n}\n/**\n * Get URL parameter by name.\n *\n * @param url -\n * @param name -\n */\n\nexport function getURLParameter(url, name) {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getQueryParameterValue(name);\n}\n/**\n * Set URL host.\n *\n * @param url - Source URL string\n * @param host - New host string\n * @returns An updated URL string\n */\n\nexport function setURLHost(url, host) {\n  const urlParsed = URLBuilder.parse(url);\n  urlParsed.setHost(host);\n  return urlParsed.toString();\n}\n/**\n * Get URL path from an URL string.\n *\n * @param url - Source URL string\n */\n\nexport function getURLPath(url) {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getPath();\n}\n/**\n * Get URL scheme from an URL string.\n *\n * @param url - Source URL string\n */\n\nexport function getURLScheme(url) {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getScheme();\n}\n/**\n * Get URL path and query from an URL string.\n *\n * @param url - Source URL string\n */\n\nexport function getURLPathAndQuery(url) {\n  const urlParsed = URLBuilder.parse(url);\n  const pathString = urlParsed.getPath();\n\n  if (!pathString) {\n    throw new RangeError(\"Invalid url without valid path.\");\n  }\n\n  let queryString = urlParsed.getQuery() || \"\";\n  queryString = queryString.trim();\n\n  if (queryString !== \"\") {\n    queryString = queryString.startsWith(\"?\") ? queryString : `?${queryString}`; // Ensure query string start with '?'\n  }\n\n  return `${pathString}${queryString}`;\n}\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @param url -\n */\n\nexport function getURLQueries(url) {\n  let queryString = URLBuilder.parse(url).getQuery();\n\n  if (!queryString) {\n    return {};\n  }\n\n  queryString = queryString.trim();\n  queryString = queryString.startsWith(\"?\") ? queryString.substr(1) : queryString;\n  let querySubStrings = queryString.split(\"&\");\n  querySubStrings = querySubStrings.filter(value => {\n    const indexOfEqual = value.indexOf(\"=\");\n    const lastIndexOfEqual = value.lastIndexOf(\"=\");\n    return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;\n  });\n  const queries = {};\n\n  for (const querySubString of querySubStrings) {\n    const splitResults = querySubString.split(\"=\");\n    const key = splitResults[0];\n    const value = splitResults[1];\n    queries[key] = value;\n  }\n\n  return queries;\n}\n/**\n * Append a string to URL query.\n *\n * @param url - Source URL string.\n * @param queryParts - String to be appended to the URL query.\n * @returns An updated URL string.\n */\n\nexport function appendToURLQuery(url, queryParts) {\n  const urlParsed = URLBuilder.parse(url);\n  let query = urlParsed.getQuery();\n\n  if (query) {\n    query += \"&\" + queryParts;\n  } else {\n    query = queryParts;\n  }\n\n  urlParsed.setQuery(query);\n  return urlParsed.toString();\n}\n/**\n * Rounds a date off to seconds.\n *\n * @param date -\n * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns Date string in ISO8061 format, with or without 7 milliseconds component\n */\n\nexport function truncatedISO8061Date(date, withMilliseconds = true) {\n  // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n  const dateString = date.toISOString();\n  return withMilliseconds ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\" : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n/**\n * Base64 encode.\n *\n * @param content -\n */\n\nexport function base64encode(content) {\n  return !isNode ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n/**\n * Base64 decode.\n *\n * @param encodedString -\n */\n\nexport function base64decode(encodedString) {\n  return !isNode ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n/**\n * Generate a 64 bytes base64 block ID string.\n *\n * @param blockIndex -\n */\n\nexport function generateBlockID(blockIDPrefix, blockIndex) {\n  // To generate a 64 bytes base64 string, source string should be 48\n  const maxSourceStringLength = 48; // A blob can have a maximum of 100,000 uncommitted blocks at any given time\n\n  const maxBlockIndexLength = 6;\n  const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;\n\n  if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {\n    blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);\n  }\n\n  const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, \"0\");\n  return base64encode(res);\n}\n/**\n * Delay specified time interval.\n *\n * @param timeInMs -\n * @param aborter -\n * @param abortError -\n */\n\nexport function delay(_x, _x2, _x3) {\n  return _delay.apply(this, arguments);\n}\n/**\n * String.prototype.padStart()\n *\n * @param currentString -\n * @param targetLength -\n * @param padString -\n */\n\nfunction _delay() {\n  _delay = _asyncToGenerator(function* (timeInMs, aborter, abortError) {\n    return new Promise((resolve, reject) => {\n      /* eslint-disable-next-line prefer-const */\n      let timeout;\n\n      const abortHandler = () => {\n        if (timeout !== undefined) {\n          clearTimeout(timeout);\n        }\n\n        reject(abortError);\n      };\n\n      const resolveHandler = () => {\n        if (aborter !== undefined) {\n          aborter.removeEventListener(\"abort\", abortHandler);\n        }\n\n        resolve();\n      };\n\n      timeout = setTimeout(resolveHandler, timeInMs);\n\n      if (aborter !== undefined) {\n        aborter.addEventListener(\"abort\", abortHandler);\n      }\n    });\n  });\n  return _delay.apply(this, arguments);\n}\n\nexport function padStart(currentString, targetLength, padString = \" \") {\n  // @ts-expect-error: TS doesn't know this code needs to run downlevel sometimes\n  if (String.prototype.padStart) {\n    return currentString.padStart(targetLength, padString);\n  }\n\n  padString = padString || \" \";\n\n  if (currentString.length > targetLength) {\n    return currentString;\n  } else {\n    targetLength = targetLength - currentString.length;\n\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n\n    return padString.slice(0, targetLength) + currentString;\n  }\n}\nexport function sanitizeURL(url) {\n  let safeURL = url;\n\n  if (getURLParameter(safeURL, URLConstants.Parameters.SIGNATURE)) {\n    safeURL = setURLParameter(safeURL, URLConstants.Parameters.SIGNATURE, \"*****\");\n  }\n\n  return safeURL;\n}\nexport function sanitizeHeaders(originalHeader) {\n  const headers = new HttpHeaders();\n\n  for (const header of originalHeader.headersArray()) {\n    if (header.name.toLowerCase() === HeaderConstants.AUTHORIZATION.toLowerCase()) {\n      headers.set(header.name, \"*****\");\n    } else if (header.name.toLowerCase() === HeaderConstants.X_MS_COPY_SOURCE) {\n      headers.set(header.name, sanitizeURL(header.value));\n    } else {\n      headers.set(header.name, header.value);\n    }\n  }\n\n  return headers;\n}\n/**\n * If two strings are equal when compared case insensitive.\n *\n * @param str1 -\n * @param str2 -\n */\n\nexport function iEqual(str1, str2) {\n  return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();\n}\n/**\n * Extracts account name from the url\n * @param url - url to extract the account name from\n * @returns with the account name\n */\n\nexport function getAccountNameFromUrl(url) {\n  const parsedUrl = URLBuilder.parse(url);\n  let accountName;\n\n  try {\n    if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n      // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n      accountName = parsedUrl.getHost().split(\".\")[0];\n    } else if (isIpEndpointStyle(parsedUrl)) {\n      // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/\n      // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/\n      // .getPath() -> /devstoreaccount1/\n      accountName = parsedUrl.getPath().split(\"/\")[1];\n    } else {\n      // Custom domain case: \"https://customdomain.com/containername/blob\".\n      accountName = \"\";\n    }\n\n    return accountName;\n  } catch (error) {\n    throw new Error(\"Unable to extract accountName with provided information.\");\n  }\n}\nexport function isIpEndpointStyle(parsedUrl) {\n  if (parsedUrl.getHost() === undefined) {\n    return false;\n  }\n\n  const host = parsedUrl.getHost() + (parsedUrl.getPort() === undefined ? \"\" : \":\" + parsedUrl.getPort()); // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.\n  // Case 2: localhost(:port), use broad regex to match port part.\n  // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.\n  // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.\n\n  return /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])){3}(:[0-9]+)?$/.test(host);\n}\n/**\n * Convert Tags to encoded string.\n *\n * @param tags -\n */\n\nexport function toBlobTagsString(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const tagPairs = [];\n\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n    }\n  }\n\n  return tagPairs.join(\"&\");\n}\n/**\n * Convert Tags type to BlobTags.\n *\n * @param tags -\n */\n\nexport function toBlobTags(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res = {\n    blobTagSet: []\n  };\n\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      res.blobTagSet.push({\n        key,\n        value\n      });\n    }\n  }\n\n  return res;\n}\n/**\n * Covert BlobTags to Tags type.\n *\n * @param tags -\n */\n\nexport function toTags(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res = {};\n\n  for (const blobTag of tags.blobTagSet) {\n    res[blobTag.key] = blobTag.value;\n  }\n\n  return res;\n}\n/**\n * Convert BlobQueryTextConfiguration to QuerySerialization type.\n *\n * @param textConfiguration -\n */\n\nexport function toQuerySerialization(textConfiguration) {\n  if (textConfiguration === undefined) {\n    return undefined;\n  }\n\n  switch (textConfiguration.kind) {\n    case \"csv\":\n      return {\n        format: {\n          type: \"delimited\",\n          delimitedTextConfiguration: {\n            columnSeparator: textConfiguration.columnSeparator || \",\",\n            fieldQuote: textConfiguration.fieldQuote || \"\",\n            recordSeparator: textConfiguration.recordSeparator,\n            escapeChar: textConfiguration.escapeCharacter || \"\",\n            headersPresent: textConfiguration.hasHeaders || false\n          }\n        }\n      };\n\n    case \"json\":\n      return {\n        format: {\n          type: \"json\",\n          jsonTextConfiguration: {\n            recordSeparator: textConfiguration.recordSeparator\n          }\n        }\n      };\n\n    case \"arrow\":\n      return {\n        format: {\n          type: \"arrow\",\n          arrowConfiguration: {\n            schema: textConfiguration.schema\n          }\n        }\n      };\n\n    case \"parquet\":\n      return {\n        format: {\n          type: \"parquet\"\n        }\n      };\n\n    default:\n      throw Error(\"Invalid BlobQueryTextConfiguration.\");\n  }\n}\nexport function parseObjectReplicationRecord(objectReplicationRecord) {\n  if (!objectReplicationRecord) {\n    return undefined;\n  }\n\n  if (\"policy-id\" in objectReplicationRecord) {\n    // If the dictionary contains a key with policy id, we are not required to do any parsing since\n    // the policy id should already be stored in the ObjectReplicationDestinationPolicyId.\n    return undefined;\n  }\n\n  const orProperties = [];\n\n  for (const key in objectReplicationRecord) {\n    const ids = key.split(\"_\");\n    const policyPrefix = \"or-\";\n\n    if (ids[0].startsWith(policyPrefix)) {\n      ids[0] = ids[0].substring(policyPrefix.length);\n    }\n\n    const rule = {\n      ruleId: ids[1],\n      replicationStatus: objectReplicationRecord[key]\n    };\n    const policyIndex = orProperties.findIndex(policy => policy.policyId === ids[0]);\n\n    if (policyIndex > -1) {\n      orProperties[policyIndex].rules.push(rule);\n    } else {\n      orProperties.push({\n        policyId: ids[0],\n        rules: [rule]\n      });\n    }\n  }\n\n  return orProperties;\n}\n/**\n * Attach a TokenCredential to an object.\n *\n * @param thing -\n * @param credential -\n */\n\nexport function attachCredential(thing, credential) {\n  thing.credential = credential;\n  return thing;\n}\nexport function httpAuthorizationToString(httpAuthorization) {\n  return httpAuthorization ? httpAuthorization.scheme + \" \" + httpAuthorization.value : undefined;\n}\nexport function BlobNameToString(name) {\n  if (name.encoded) {\n    return decodeURIComponent(name.content);\n  } else {\n    return name.content;\n  }\n}\nexport function ConvertInternalResponseOfListBlobFlat(internalResponse) {\n  return Object.assign(Object.assign({}, internalResponse), {\n    segment: {\n      blobItems: internalResponse.segment.blobItems.map(blobItemInteral => {\n        const blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n          name: BlobNameToString(blobItemInteral.name)\n        });\n        return blobItem;\n      })\n    }\n  });\n}\nexport function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {\n  var _a;\n\n  return Object.assign(Object.assign({}, internalResponse), {\n    segment: {\n      blobPrefixes: (_a = internalResponse.segment.blobPrefixes) === null || _a === void 0 ? void 0 : _a.map(blobPrefixInternal => {\n        const blobPrefix = {\n          name: BlobNameToString(blobPrefixInternal.name)\n        };\n        return blobPrefix;\n      }),\n      blobItems: internalResponse.segment.blobItems.map(blobItemInteral => {\n        const blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n          name: BlobNameToString(blobItemInteral.name)\n        });\n        return blobItem;\n      })\n    }\n  });\n}\n\nfunction decodeBase64String(value) {\n  if (isNode) {\n    return Buffer.from(value, \"base64\");\n  } else {\n    const byteString = atob(value);\n    const arr = new Uint8Array(byteString.length);\n\n    for (let i = 0; i < byteString.length; i++) {\n      arr[i] = byteString.charCodeAt(i);\n    }\n\n    return arr;\n  }\n}\n\nfunction ParseBoolean(content) {\n  if (content === undefined) return undefined;\n  if (content === \"true\") return true;\n  if (content === \"false\") return false;\n  return undefined;\n}\n\nfunction ParseBlobName(blobNameInXML) {\n  if (blobNameInXML[\"$\"] !== undefined && blobNameInXML[\"#\"] !== undefined) {\n    return {\n      encoded: ParseBoolean(blobNameInXML[\"$\"][\"Encoded\"]),\n      content: blobNameInXML[\"#\"]\n    };\n  } else {\n    return {\n      encoded: false,\n      content: blobNameInXML\n    };\n  }\n}\n\nfunction ParseBlobProperties(blobPropertiesInXML) {\n  const blobProperties = blobPropertiesInXML;\n\n  if (blobPropertiesInXML[\"Creation-Time\"]) {\n    blobProperties.createdOn = new Date(blobPropertiesInXML[\"Creation-Time\"]);\n    delete blobProperties[\"Creation-Time\"];\n  }\n\n  if (blobPropertiesInXML[\"Last-Modified\"]) {\n    blobProperties.lastModified = new Date(blobPropertiesInXML[\"Last-Modified\"]);\n    delete blobProperties[\"Last-Modified\"];\n  }\n\n  if (blobPropertiesInXML[\"Etag\"]) {\n    blobProperties.etag = blobPropertiesInXML[\"Etag\"];\n    delete blobProperties[\"Etag\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-Length\"]) {\n    blobProperties.contentLength = parseFloat(blobPropertiesInXML[\"Content-Length\"]);\n    delete blobProperties[\"Content-Length\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-Type\"]) {\n    blobProperties.contentType = blobPropertiesInXML[\"Content-Type\"];\n    delete blobProperties[\"Content-Type\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-Encoding\"]) {\n    blobProperties.contentEncoding = blobPropertiesInXML[\"Content-Encoding\"];\n    delete blobProperties[\"Content-Encoding\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-Language\"]) {\n    blobProperties.contentLanguage = blobPropertiesInXML[\"Content-Language\"];\n    delete blobProperties[\"Content-Language\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-MD5\"]) {\n    blobProperties.contentMD5 = decodeBase64String(blobPropertiesInXML[\"Content-MD5\"]);\n    delete blobProperties[\"Content-MD5\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-Disposition\"]) {\n    blobProperties.contentDisposition = blobPropertiesInXML[\"Content-Disposition\"];\n    delete blobProperties[\"Content-Disposition\"];\n  }\n\n  if (blobPropertiesInXML[\"Cache-Control\"]) {\n    blobProperties.cacheControl = blobPropertiesInXML[\"Cache-Control\"];\n    delete blobProperties[\"Cache-Control\"];\n  }\n\n  if (blobPropertiesInXML[\"x-ms-blob-sequence-number\"]) {\n    blobProperties.blobSequenceNumber = parseFloat(blobPropertiesInXML[\"x-ms-blob-sequence-number\"]);\n    delete blobProperties[\"x-ms-blob-sequence-number\"];\n  }\n\n  if (blobPropertiesInXML[\"BlobType\"]) {\n    blobProperties.blobType = blobPropertiesInXML[\"BlobType\"];\n    delete blobProperties[\"BlobType\"];\n  }\n\n  if (blobPropertiesInXML[\"LeaseStatus\"]) {\n    blobProperties.leaseStatus = blobPropertiesInXML[\"LeaseStatus\"];\n    delete blobProperties[\"LeaseStatus\"];\n  }\n\n  if (blobPropertiesInXML[\"LeaseState\"]) {\n    blobProperties.leaseState = blobPropertiesInXML[\"LeaseState\"];\n    delete blobProperties[\"LeaseState\"];\n  }\n\n  if (blobPropertiesInXML[\"LeaseDuration\"]) {\n    blobProperties.leaseDuration = blobPropertiesInXML[\"LeaseDuration\"];\n    delete blobProperties[\"LeaseDuration\"];\n  }\n\n  if (blobPropertiesInXML[\"CopyId\"]) {\n    blobProperties.copyId = blobPropertiesInXML[\"CopyId\"];\n    delete blobProperties[\"CopyId\"];\n  }\n\n  if (blobPropertiesInXML[\"CopyStatus\"]) {\n    blobProperties.copyStatus = blobPropertiesInXML[\"CopyStatus\"];\n    delete blobProperties[\"CopyStatus\"];\n  }\n\n  if (blobPropertiesInXML[\"CopySource\"]) {\n    blobProperties.copySource = blobPropertiesInXML[\"CopySource\"];\n    delete blobProperties[\"CopySource\"];\n  }\n\n  if (blobPropertiesInXML[\"CopyProgress\"]) {\n    blobProperties.copyProgress = blobPropertiesInXML[\"CopyProgress\"];\n    delete blobProperties[\"CopyProgress\"];\n  }\n\n  if (blobPropertiesInXML[\"CopyCompletionTime\"]) {\n    blobProperties.copyCompletedOn = new Date(blobPropertiesInXML[\"CopyCompletionTime\"]);\n    delete blobProperties[\"CopyCompletionTime\"];\n  }\n\n  if (blobPropertiesInXML[\"CopyStatusDescription\"]) {\n    blobProperties.copyStatusDescription = blobPropertiesInXML[\"CopyStatusDescription\"];\n    delete blobProperties[\"CopyStatusDescription\"];\n  }\n\n  if (blobPropertiesInXML[\"ServerEncrypted\"]) {\n    blobProperties.serverEncrypted = ParseBoolean(blobPropertiesInXML[\"ServerEncrypted\"]);\n    delete blobProperties[\"ServerEncrypted\"];\n  }\n\n  if (blobPropertiesInXML[\"IncrementalCopy\"]) {\n    blobProperties.incrementalCopy = ParseBoolean(blobPropertiesInXML[\"IncrementalCopy\"]);\n    delete blobProperties[\"IncrementalCopy\"];\n  }\n\n  if (blobPropertiesInXML[\"DestinationSnapshot\"]) {\n    blobProperties.destinationSnapshot = blobPropertiesInXML[\"DestinationSnapshot\"];\n    delete blobProperties[\"DestinationSnapshot\"];\n  }\n\n  if (blobPropertiesInXML[\"DeletedTime\"]) {\n    blobProperties.deletedOn = new Date(blobPropertiesInXML[\"DeletedTime\"]);\n    delete blobProperties[\"DeletedTime\"];\n  }\n\n  if (blobPropertiesInXML[\"RemainingRetentionDays\"]) {\n    blobProperties.remainingRetentionDays = parseFloat(blobPropertiesInXML[\"RemainingRetentionDays\"]);\n    delete blobProperties[\"RemainingRetentionDays\"];\n  }\n\n  if (blobPropertiesInXML[\"AccessTier\"]) {\n    blobProperties.accessTier = blobPropertiesInXML[\"AccessTier\"];\n    delete blobProperties[\"AccessTier\"];\n  }\n\n  if (blobPropertiesInXML[\"AccessTierInferred\"]) {\n    blobProperties.accessTierInferred = ParseBoolean(blobPropertiesInXML[\"AccessTierInferred\"]);\n    delete blobProperties[\"AccessTierInferred\"];\n  }\n\n  if (blobPropertiesInXML[\"ArchiveStatus\"]) {\n    blobProperties.archiveStatus = blobPropertiesInXML[\"ArchiveStatus\"];\n    delete blobProperties[\"ArchiveStatus\"];\n  }\n\n  if (blobPropertiesInXML[\"CustomerProvidedKeySha256\"]) {\n    blobProperties.customerProvidedKeySha256 = blobPropertiesInXML[\"CustomerProvidedKeySha256\"];\n    delete blobProperties[\"CustomerProvidedKeySha256\"];\n  }\n\n  if (blobPropertiesInXML[\"EncryptionScope\"]) {\n    blobProperties.encryptionScope = blobPropertiesInXML[\"EncryptionScope\"];\n    delete blobProperties[\"EncryptionScope\"];\n  }\n\n  if (blobPropertiesInXML[\"AccessTierChangeTime\"]) {\n    blobProperties.accessTierChangedOn = new Date(blobPropertiesInXML[\"AccessTierChangeTime\"]);\n    delete blobProperties[\"AccessTierChangeTime\"];\n  }\n\n  if (blobPropertiesInXML[\"TagCount\"]) {\n    blobProperties.tagCount = parseFloat(blobPropertiesInXML[\"TagCount\"]);\n    delete blobProperties[\"TagCount\"];\n  }\n\n  if (blobPropertiesInXML[\"Expiry-Time\"]) {\n    blobProperties.expiresOn = new Date(blobPropertiesInXML[\"Expiry-Time\"]);\n    delete blobProperties[\"Expiry-Time\"];\n  }\n\n  if (blobPropertiesInXML[\"Sealed\"]) {\n    blobProperties.isSealed = ParseBoolean(blobPropertiesInXML[\"Sealed\"]);\n    delete blobProperties[\"Sealed\"];\n  }\n\n  if (blobPropertiesInXML[\"RehydratePriority\"]) {\n    blobProperties.rehydratePriority = blobPropertiesInXML[\"RehydratePriority\"];\n    delete blobProperties[\"RehydratePriority\"];\n  }\n\n  if (blobPropertiesInXML[\"LastAccessTime\"]) {\n    blobProperties.lastAccessedOn = new Date(blobPropertiesInXML[\"LastAccessTime\"]);\n    delete blobProperties[\"LastAccessTime\"];\n  }\n\n  if (blobPropertiesInXML[\"ImmutabilityPolicyUntilDate\"]) {\n    blobProperties.immutabilityPolicyExpiresOn = new Date(blobPropertiesInXML[\"ImmutabilityPolicyUntilDate\"]);\n    delete blobProperties[\"ImmutabilityPolicyUntilDate\"];\n  }\n\n  if (blobPropertiesInXML[\"ImmutabilityPolicyMode\"]) {\n    blobProperties.immutabilityPolicyMode = blobPropertiesInXML[\"ImmutabilityPolicyMode\"];\n    delete blobProperties[\"ImmutabilityPolicyMode\"];\n  }\n\n  if (blobPropertiesInXML[\"LegalHold\"]) {\n    blobProperties.legalHold = ParseBoolean(blobPropertiesInXML[\"LegalHold\"]);\n    delete blobProperties[\"LegalHold\"];\n  }\n\n  return blobProperties;\n}\n\nfunction ParseBlobItem(blobInXML) {\n  const blobItem = blobInXML;\n  blobItem.properties = ParseBlobProperties(blobInXML[\"Properties\"]);\n  delete blobItem[\"Properties\"];\n  blobItem.name = ParseBlobName(blobInXML[\"Name\"]);\n  delete blobItem[\"Name\"];\n  blobItem.deleted = ParseBoolean(blobInXML[\"Deleted\"]);\n  delete blobItem[\"Deleted\"];\n\n  if (blobInXML[\"Snapshot\"]) {\n    blobItem.snapshot = blobInXML[\"Snapshot\"];\n    delete blobItem[\"Snapshot\"];\n  }\n\n  if (blobInXML[\"VersionId\"]) {\n    blobItem.versionId = blobInXML[\"VersionId\"];\n    delete blobItem[\"VersionId\"];\n  }\n\n  if (blobInXML[\"IsCurrentVersion\"]) {\n    blobItem.isCurrentVersion = ParseBoolean(blobInXML[\"IsCurrentVersion\"]);\n    delete blobItem[\"IsCurrentVersion\"];\n  }\n\n  if (blobInXML[\"Metadata\"]) {\n    blobItem.metadata = blobInXML[\"Metadata\"];\n    delete blobItem[\"Metadata\"];\n  }\n\n  if (blobInXML[\"Tags\"]) {\n    blobItem.blobTags = ParseBlobTags(blobInXML[\"Tags\"]);\n    delete blobItem[\"Tags\"];\n  }\n\n  if (blobInXML[\"OrMetadata\"]) {\n    blobItem.objectReplicationMetadata = blobInXML[\"OrMetadata\"];\n    delete blobItem[\"OrMetadata\"];\n  }\n\n  if (blobInXML[\"HasVersionsOnly\"]) {\n    blobItem.hasVersionsOnly = ParseBoolean(blobInXML[\"HasVersionsOnly\"]);\n    delete blobItem[\"HasVersionsOnly\"];\n  }\n\n  return blobItem;\n}\n\nfunction ParseBlobPrefix(blobPrefixInXML) {\n  return {\n    name: ParseBlobName(blobPrefixInXML[\"Name\"])\n  };\n}\n\nfunction ParseBlobTag(blobTagInXML) {\n  return {\n    key: blobTagInXML[\"Key\"],\n    value: blobTagInXML[\"Value\"]\n  };\n}\n\nfunction ParseBlobTags(blobTagsInXML) {\n  if (blobTagsInXML === undefined || blobTagsInXML[\"TagSet\"] === undefined || blobTagsInXML[\"TagSet\"][\"Tag\"] === undefined) {\n    return undefined;\n  }\n\n  const blobTagSet = [];\n\n  if (blobTagsInXML[\"TagSet\"][\"Tag\"] instanceof Array) {\n    blobTagsInXML[\"TagSet\"][\"Tag\"].forEach(blobTagInXML => {\n      blobTagSet.push(ParseBlobTag(blobTagInXML));\n    });\n  } else {\n    blobTagSet.push(ParseBlobTag(blobTagsInXML[\"TagSet\"][\"Tag\"]));\n  }\n\n  return {\n    blobTagSet: blobTagSet\n  };\n}\n\nexport function ProcessBlobItems(blobArrayInXML) {\n  const blobItems = [];\n\n  if (blobArrayInXML instanceof Array) {\n    blobArrayInXML.forEach(blobInXML => {\n      blobItems.push(ParseBlobItem(blobInXML));\n    });\n  } else {\n    blobItems.push(ParseBlobItem(blobArrayInXML));\n  }\n\n  return blobItems;\n}\nexport function ProcessBlobPrefixes(blobPrefixesInXML) {\n  const blobPrefixes = [];\n\n  if (blobPrefixesInXML instanceof Array) {\n    blobPrefixesInXML.forEach(blobPrefixInXML => {\n      blobPrefixes.push(ParseBlobPrefix(blobPrefixInXML));\n    });\n  } else {\n    blobPrefixes.push(ParseBlobPrefix(blobPrefixesInXML));\n  }\n\n  return blobPrefixes;\n}\nexport function* ExtractPageRangeInfoItems(getPageRangesSegment) {\n  let pageRange = [];\n  let clearRange = [];\n  if (getPageRangesSegment.pageRange) pageRange = getPageRangesSegment.pageRange;\n  if (getPageRangesSegment.clearRange) clearRange = getPageRangesSegment.clearRange;\n  let pageRangeIndex = 0;\n  let clearRangeIndex = 0;\n\n  while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {\n    if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {\n      yield {\n        start: pageRange[pageRangeIndex].start,\n        end: pageRange[pageRangeIndex].end,\n        isClear: false\n      };\n      ++pageRangeIndex;\n    } else {\n      yield {\n        start: clearRange[clearRangeIndex].start,\n        end: clearRange[clearRangeIndex].end,\n        isClear: true\n      };\n      ++clearRangeIndex;\n    }\n  }\n\n  for (; pageRangeIndex < pageRange.length; ++pageRangeIndex) {\n    yield {\n      start: pageRange[pageRangeIndex].start,\n      end: pageRange[pageRangeIndex].end,\n      isClear: false\n    };\n  }\n\n  for (; clearRangeIndex < clearRange.length; ++clearRangeIndex) {\n    yield {\n      start: clearRange[clearRangeIndex].start,\n      end: clearRange[clearRangeIndex].end,\n      isClear: true\n    };\n  }\n} //# sourceMappingURL=utils.common.js.map","map":{"version":3,"sources":["C:/Users/Equipo/source/Tgsc-Proyectos/youManager-web/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/utils.common.js"],"names":["HttpHeaders","isNode","URLBuilder","DevelopmentConnectionString","HeaderConstants","URLConstants","escapeURLPath","url","urlParsed","parse","path","getPath","escape","setPath","toString","getProxyUriFromDevConnString","connectionString","proxyUri","search","matchCredentials","split","element","trim","startsWith","match","getValueInConnString","argument","elements","extractConnectionStringParts","blobEndpoint","endsWith","slice","defaultEndpointsProtocol","accountName","accountKey","Buffer","from","endpointSuffix","protocol","toLowerCase","Error","length","kind","accountSas","getAccountNameFromUrl","text","encodeURIComponent","replace","appendToURLPath","name","setURLParameter","value","setQueryParameter","getURLParameter","getQueryParameterValue","setURLHost","host","setHost","getURLPath","getURLScheme","getScheme","getURLPathAndQuery","pathString","RangeError","queryString","getQuery","getURLQueries","substr","querySubStrings","filter","indexOfEqual","indexOf","lastIndexOfEqual","lastIndexOf","queries","querySubString","splitResults","key","appendToURLQuery","queryParts","query","setQuery","truncatedISO8061Date","date","withMilliseconds","dateString","toISOString","substring","base64encode","content","btoa","base64decode","encodedString","atob","generateBlockID","blockIDPrefix","blockIndex","maxSourceStringLength","maxBlockIndexLength","maxAllowedBlockIDPrefixLength","res","padStart","delay","timeInMs","aborter","abortError","Promise","resolve","reject","timeout","abortHandler","undefined","clearTimeout","resolveHandler","removeEventListener","setTimeout","addEventListener","currentString","targetLength","padString","String","prototype","repeat","sanitizeURL","safeURL","Parameters","SIGNATURE","sanitizeHeaders","originalHeader","headers","header","headersArray","AUTHORIZATION","set","X_MS_COPY_SOURCE","iEqual","str1","str2","toLocaleLowerCase","parsedUrl","getHost","isIpEndpointStyle","error","getPort","test","toBlobTagsString","tags","tagPairs","Object","hasOwnProperty","call","push","join","toBlobTags","blobTagSet","toTags","blobTag","toQuerySerialization","textConfiguration","format","type","delimitedTextConfiguration","columnSeparator","fieldQuote","recordSeparator","escapeChar","escapeCharacter","headersPresent","hasHeaders","jsonTextConfiguration","arrowConfiguration","schema","parseObjectReplicationRecord","objectReplicationRecord","orProperties","ids","policyPrefix","rule","ruleId","replicationStatus","policyIndex","findIndex","policy","policyId","rules","attachCredential","thing","credential","httpAuthorizationToString","httpAuthorization","scheme","BlobNameToString","encoded","decodeURIComponent","ConvertInternalResponseOfListBlobFlat","internalResponse","assign","segment","blobItems","map","blobItemInteral","blobItem","ConvertInternalResponseOfListBlobHierarchy","_a","blobPrefixes","blobPrefixInternal","blobPrefix","decodeBase64String","byteString","arr","Uint8Array","i","charCodeAt","ParseBoolean","ParseBlobName","blobNameInXML","ParseBlobProperties","blobPropertiesInXML","blobProperties","createdOn","Date","lastModified","etag","contentLength","parseFloat","contentType","contentEncoding","contentLanguage","contentMD5","contentDisposition","cacheControl","blobSequenceNumber","blobType","leaseStatus","leaseState","leaseDuration","copyId","copyStatus","copySource","copyProgress","copyCompletedOn","copyStatusDescription","serverEncrypted","incrementalCopy","destinationSnapshot","deletedOn","remainingRetentionDays","accessTier","accessTierInferred","archiveStatus","customerProvidedKeySha256","encryptionScope","accessTierChangedOn","tagCount","expiresOn","isSealed","rehydratePriority","lastAccessedOn","immutabilityPolicyExpiresOn","immutabilityPolicyMode","legalHold","ParseBlobItem","blobInXML","properties","deleted","snapshot","versionId","isCurrentVersion","metadata","blobTags","ParseBlobTags","objectReplicationMetadata","hasVersionsOnly","ParseBlobPrefix","blobPrefixInXML","ParseBlobTag","blobTagInXML","blobTagsInXML","Array","forEach","ProcessBlobItems","blobArrayInXML","ProcessBlobPrefixes","blobPrefixesInXML","ExtractPageRangeInfoItems","getPageRangesSegment","pageRange","clearRange","pageRangeIndex","clearRangeIndex","start","end","isClear"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders, isNode, URLBuilder } from \"@azure/core-http\";\nimport { DevelopmentConnectionString, HeaderConstants, URLConstants } from \"./constants\";\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JS SDKs\n *\n * When customers pass a URL string into XxxClient classes constructor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XxxClient constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" instead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `containerClient.getBlobClient(blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @param url -\n */\nexport function escapeURLPath(url) {\n    const urlParsed = URLBuilder.parse(url);\n    let path = urlParsed.getPath();\n    path = path || \"/\";\n    path = escape(path);\n    urlParsed.setPath(path);\n    return urlParsed.toString();\n}\nfunction getProxyUriFromDevConnString(connectionString) {\n    // Development Connection String\n    // https://docs.microsoft.com/en-us/azure/storage/common/storage-configure-connection-string#connect-to-the-emulator-account-using-the-well-known-account-name-and-key\n    let proxyUri = \"\";\n    if (connectionString.search(\"DevelopmentStorageProxyUri=\") !== -1) {\n        // CONNECTION_STRING=UseDevelopmentStorage=true;DevelopmentStorageProxyUri=http://myProxyUri\n        const matchCredentials = connectionString.split(\";\");\n        for (const element of matchCredentials) {\n            if (element.trim().startsWith(\"DevelopmentStorageProxyUri=\")) {\n                proxyUri = element.trim().match(\"DevelopmentStorageProxyUri=(.*)\")[1];\n            }\n        }\n    }\n    return proxyUri;\n}\nexport function getValueInConnString(connectionString, argument) {\n    const elements = connectionString.split(\";\");\n    for (const element of elements) {\n        if (element.trim().startsWith(argument)) {\n            return element.trim().match(argument + \"=(.*)\")[1];\n        }\n    }\n    return \"\";\n}\n/**\n * Extracts the parts of an Azure Storage account connection string.\n *\n * @param connectionString - Connection string.\n * @returns String key value pairs of the storage account's url and credentials.\n */\nexport function extractConnectionStringParts(connectionString) {\n    let proxyUri = \"\";\n    if (connectionString.startsWith(\"UseDevelopmentStorage=true\")) {\n        // Development connection string\n        proxyUri = getProxyUriFromDevConnString(connectionString);\n        connectionString = DevelopmentConnectionString;\n    }\n    // Matching BlobEndpoint in the Account connection string\n    let blobEndpoint = getValueInConnString(connectionString, \"BlobEndpoint\");\n    // Slicing off '/' at the end if exists\n    // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)\n    blobEndpoint = blobEndpoint.endsWith(\"/\") ? blobEndpoint.slice(0, -1) : blobEndpoint;\n    if (connectionString.search(\"DefaultEndpointsProtocol=\") !== -1 &&\n        connectionString.search(\"AccountKey=\") !== -1) {\n        // Account connection string\n        let defaultEndpointsProtocol = \"\";\n        let accountName = \"\";\n        let accountKey = Buffer.from(\"accountKey\", \"base64\");\n        let endpointSuffix = \"\";\n        // Get account name and key\n        accountName = getValueInConnString(connectionString, \"AccountName\");\n        accountKey = Buffer.from(getValueInConnString(connectionString, \"AccountKey\"), \"base64\");\n        if (!blobEndpoint) {\n            // BlobEndpoint is not present in the Account connection string\n            // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`\n            defaultEndpointsProtocol = getValueInConnString(connectionString, \"DefaultEndpointsProtocol\");\n            const protocol = defaultEndpointsProtocol.toLowerCase();\n            if (protocol !== \"https\" && protocol !== \"http\") {\n                throw new Error(\"Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'\");\n            }\n            endpointSuffix = getValueInConnString(connectionString, \"EndpointSuffix\");\n            if (!endpointSuffix) {\n                throw new Error(\"Invalid EndpointSuffix in the provided Connection String\");\n            }\n            blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n        }\n        if (!accountName) {\n            throw new Error(\"Invalid AccountName in the provided Connection String\");\n        }\n        else if (accountKey.length === 0) {\n            throw new Error(\"Invalid AccountKey in the provided Connection String\");\n        }\n        return {\n            kind: \"AccountConnString\",\n            url: blobEndpoint,\n            accountName,\n            accountKey,\n            proxyUri,\n        };\n    }\n    else {\n        // SAS connection string\n        const accountSas = getValueInConnString(connectionString, \"SharedAccessSignature\");\n        const accountName = getAccountNameFromUrl(blobEndpoint);\n        if (!blobEndpoint) {\n            throw new Error(\"Invalid BlobEndpoint in the provided SAS Connection String\");\n        }\n        else if (!accountSas) {\n            throw new Error(\"Invalid SharedAccessSignature in the provided SAS Connection String\");\n        }\n        return { kind: \"SASConnString\", url: blobEndpoint, accountName, accountSas };\n    }\n}\n/**\n * Internal escape method implemented Strategy Two mentioned in escapeURL() description.\n *\n * @param text -\n */\nfunction escape(text) {\n    return encodeURIComponent(text)\n        .replace(/%2F/g, \"/\") // Don't escape for \"/\"\n        .replace(/'/g, \"%27\") // Escape for \"'\"\n        .replace(/\\+/g, \"%20\")\n        .replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @param url - Source URL string\n * @param name - String to be appended to URL\n * @returns An updated URL string\n */\nexport function appendToURLPath(url, name) {\n    const urlParsed = URLBuilder.parse(url);\n    let path = urlParsed.getPath();\n    path = path ? (path.endsWith(\"/\") ? `${path}${name}` : `${path}/${name}`) : name;\n    urlParsed.setPath(path);\n    return urlParsed.toString();\n}\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @param url - Source URL string\n * @param name - Parameter name\n * @param value - Parameter value\n * @returns An updated URL string\n */\nexport function setURLParameter(url, name, value) {\n    const urlParsed = URLBuilder.parse(url);\n    urlParsed.setQueryParameter(name, value);\n    return urlParsed.toString();\n}\n/**\n * Get URL parameter by name.\n *\n * @param url -\n * @param name -\n */\nexport function getURLParameter(url, name) {\n    const urlParsed = URLBuilder.parse(url);\n    return urlParsed.getQueryParameterValue(name);\n}\n/**\n * Set URL host.\n *\n * @param url - Source URL string\n * @param host - New host string\n * @returns An updated URL string\n */\nexport function setURLHost(url, host) {\n    const urlParsed = URLBuilder.parse(url);\n    urlParsed.setHost(host);\n    return urlParsed.toString();\n}\n/**\n * Get URL path from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPath(url) {\n    const urlParsed = URLBuilder.parse(url);\n    return urlParsed.getPath();\n}\n/**\n * Get URL scheme from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLScheme(url) {\n    const urlParsed = URLBuilder.parse(url);\n    return urlParsed.getScheme();\n}\n/**\n * Get URL path and query from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPathAndQuery(url) {\n    const urlParsed = URLBuilder.parse(url);\n    const pathString = urlParsed.getPath();\n    if (!pathString) {\n        throw new RangeError(\"Invalid url without valid path.\");\n    }\n    let queryString = urlParsed.getQuery() || \"\";\n    queryString = queryString.trim();\n    if (queryString !== \"\") {\n        queryString = queryString.startsWith(\"?\") ? queryString : `?${queryString}`; // Ensure query string start with '?'\n    }\n    return `${pathString}${queryString}`;\n}\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @param url -\n */\nexport function getURLQueries(url) {\n    let queryString = URLBuilder.parse(url).getQuery();\n    if (!queryString) {\n        return {};\n    }\n    queryString = queryString.trim();\n    queryString = queryString.startsWith(\"?\") ? queryString.substr(1) : queryString;\n    let querySubStrings = queryString.split(\"&\");\n    querySubStrings = querySubStrings.filter((value) => {\n        const indexOfEqual = value.indexOf(\"=\");\n        const lastIndexOfEqual = value.lastIndexOf(\"=\");\n        return (indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1);\n    });\n    const queries = {};\n    for (const querySubString of querySubStrings) {\n        const splitResults = querySubString.split(\"=\");\n        const key = splitResults[0];\n        const value = splitResults[1];\n        queries[key] = value;\n    }\n    return queries;\n}\n/**\n * Append a string to URL query.\n *\n * @param url - Source URL string.\n * @param queryParts - String to be appended to the URL query.\n * @returns An updated URL string.\n */\nexport function appendToURLQuery(url, queryParts) {\n    const urlParsed = URLBuilder.parse(url);\n    let query = urlParsed.getQuery();\n    if (query) {\n        query += \"&\" + queryParts;\n    }\n    else {\n        query = queryParts;\n    }\n    urlParsed.setQuery(query);\n    return urlParsed.toString();\n}\n/**\n * Rounds a date off to seconds.\n *\n * @param date -\n * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns Date string in ISO8061 format, with or without 7 milliseconds component\n */\nexport function truncatedISO8061Date(date, withMilliseconds = true) {\n    // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n    const dateString = date.toISOString();\n    return withMilliseconds\n        ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\"\n        : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n/**\n * Base64 encode.\n *\n * @param content -\n */\nexport function base64encode(content) {\n    return !isNode ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n/**\n * Base64 decode.\n *\n * @param encodedString -\n */\nexport function base64decode(encodedString) {\n    return !isNode ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n/**\n * Generate a 64 bytes base64 block ID string.\n *\n * @param blockIndex -\n */\nexport function generateBlockID(blockIDPrefix, blockIndex) {\n    // To generate a 64 bytes base64 string, source string should be 48\n    const maxSourceStringLength = 48;\n    // A blob can have a maximum of 100,000 uncommitted blocks at any given time\n    const maxBlockIndexLength = 6;\n    const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;\n    if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {\n        blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);\n    }\n    const res = blockIDPrefix +\n        padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, \"0\");\n    return base64encode(res);\n}\n/**\n * Delay specified time interval.\n *\n * @param timeInMs -\n * @param aborter -\n * @param abortError -\n */\nexport async function delay(timeInMs, aborter, abortError) {\n    return new Promise((resolve, reject) => {\n        /* eslint-disable-next-line prefer-const */\n        let timeout;\n        const abortHandler = () => {\n            if (timeout !== undefined) {\n                clearTimeout(timeout);\n            }\n            reject(abortError);\n        };\n        const resolveHandler = () => {\n            if (aborter !== undefined) {\n                aborter.removeEventListener(\"abort\", abortHandler);\n            }\n            resolve();\n        };\n        timeout = setTimeout(resolveHandler, timeInMs);\n        if (aborter !== undefined) {\n            aborter.addEventListener(\"abort\", abortHandler);\n        }\n    });\n}\n/**\n * String.prototype.padStart()\n *\n * @param currentString -\n * @param targetLength -\n * @param padString -\n */\nexport function padStart(currentString, targetLength, padString = \" \") {\n    // @ts-expect-error: TS doesn't know this code needs to run downlevel sometimes\n    if (String.prototype.padStart) {\n        return currentString.padStart(targetLength, padString);\n    }\n    padString = padString || \" \";\n    if (currentString.length > targetLength) {\n        return currentString;\n    }\n    else {\n        targetLength = targetLength - currentString.length;\n        if (targetLength > padString.length) {\n            padString += padString.repeat(targetLength / padString.length);\n        }\n        return padString.slice(0, targetLength) + currentString;\n    }\n}\nexport function sanitizeURL(url) {\n    let safeURL = url;\n    if (getURLParameter(safeURL, URLConstants.Parameters.SIGNATURE)) {\n        safeURL = setURLParameter(safeURL, URLConstants.Parameters.SIGNATURE, \"*****\");\n    }\n    return safeURL;\n}\nexport function sanitizeHeaders(originalHeader) {\n    const headers = new HttpHeaders();\n    for (const header of originalHeader.headersArray()) {\n        if (header.name.toLowerCase() === HeaderConstants.AUTHORIZATION.toLowerCase()) {\n            headers.set(header.name, \"*****\");\n        }\n        else if (header.name.toLowerCase() === HeaderConstants.X_MS_COPY_SOURCE) {\n            headers.set(header.name, sanitizeURL(header.value));\n        }\n        else {\n            headers.set(header.name, header.value);\n        }\n    }\n    return headers;\n}\n/**\n * If two strings are equal when compared case insensitive.\n *\n * @param str1 -\n * @param str2 -\n */\nexport function iEqual(str1, str2) {\n    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();\n}\n/**\n * Extracts account name from the url\n * @param url - url to extract the account name from\n * @returns with the account name\n */\nexport function getAccountNameFromUrl(url) {\n    const parsedUrl = URLBuilder.parse(url);\n    let accountName;\n    try {\n        if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n            // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n            accountName = parsedUrl.getHost().split(\".\")[0];\n        }\n        else if (isIpEndpointStyle(parsedUrl)) {\n            // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/\n            // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/\n            // .getPath() -> /devstoreaccount1/\n            accountName = parsedUrl.getPath().split(\"/\")[1];\n        }\n        else {\n            // Custom domain case: \"https://customdomain.com/containername/blob\".\n            accountName = \"\";\n        }\n        return accountName;\n    }\n    catch (error) {\n        throw new Error(\"Unable to extract accountName with provided information.\");\n    }\n}\nexport function isIpEndpointStyle(parsedUrl) {\n    if (parsedUrl.getHost() === undefined) {\n        return false;\n    }\n    const host = parsedUrl.getHost() + (parsedUrl.getPort() === undefined ? \"\" : \":\" + parsedUrl.getPort());\n    // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.\n    // Case 2: localhost(:port), use broad regex to match port part.\n    // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.\n    // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.\n    return /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])){3}(:[0-9]+)?$/.test(host);\n}\n/**\n * Convert Tags to encoded string.\n *\n * @param tags -\n */\nexport function toBlobTagsString(tags) {\n    if (tags === undefined) {\n        return undefined;\n    }\n    const tagPairs = [];\n    for (const key in tags) {\n        if (Object.prototype.hasOwnProperty.call(tags, key)) {\n            const value = tags[key];\n            tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n        }\n    }\n    return tagPairs.join(\"&\");\n}\n/**\n * Convert Tags type to BlobTags.\n *\n * @param tags -\n */\nexport function toBlobTags(tags) {\n    if (tags === undefined) {\n        return undefined;\n    }\n    const res = {\n        blobTagSet: [],\n    };\n    for (const key in tags) {\n        if (Object.prototype.hasOwnProperty.call(tags, key)) {\n            const value = tags[key];\n            res.blobTagSet.push({\n                key,\n                value,\n            });\n        }\n    }\n    return res;\n}\n/**\n * Covert BlobTags to Tags type.\n *\n * @param tags -\n */\nexport function toTags(tags) {\n    if (tags === undefined) {\n        return undefined;\n    }\n    const res = {};\n    for (const blobTag of tags.blobTagSet) {\n        res[blobTag.key] = blobTag.value;\n    }\n    return res;\n}\n/**\n * Convert BlobQueryTextConfiguration to QuerySerialization type.\n *\n * @param textConfiguration -\n */\nexport function toQuerySerialization(textConfiguration) {\n    if (textConfiguration === undefined) {\n        return undefined;\n    }\n    switch (textConfiguration.kind) {\n        case \"csv\":\n            return {\n                format: {\n                    type: \"delimited\",\n                    delimitedTextConfiguration: {\n                        columnSeparator: textConfiguration.columnSeparator || \",\",\n                        fieldQuote: textConfiguration.fieldQuote || \"\",\n                        recordSeparator: textConfiguration.recordSeparator,\n                        escapeChar: textConfiguration.escapeCharacter || \"\",\n                        headersPresent: textConfiguration.hasHeaders || false,\n                    },\n                },\n            };\n        case \"json\":\n            return {\n                format: {\n                    type: \"json\",\n                    jsonTextConfiguration: {\n                        recordSeparator: textConfiguration.recordSeparator,\n                    },\n                },\n            };\n        case \"arrow\":\n            return {\n                format: {\n                    type: \"arrow\",\n                    arrowConfiguration: {\n                        schema: textConfiguration.schema,\n                    },\n                },\n            };\n        case \"parquet\":\n            return {\n                format: {\n                    type: \"parquet\",\n                },\n            };\n        default:\n            throw Error(\"Invalid BlobQueryTextConfiguration.\");\n    }\n}\nexport function parseObjectReplicationRecord(objectReplicationRecord) {\n    if (!objectReplicationRecord) {\n        return undefined;\n    }\n    if (\"policy-id\" in objectReplicationRecord) {\n        // If the dictionary contains a key with policy id, we are not required to do any parsing since\n        // the policy id should already be stored in the ObjectReplicationDestinationPolicyId.\n        return undefined;\n    }\n    const orProperties = [];\n    for (const key in objectReplicationRecord) {\n        const ids = key.split(\"_\");\n        const policyPrefix = \"or-\";\n        if (ids[0].startsWith(policyPrefix)) {\n            ids[0] = ids[0].substring(policyPrefix.length);\n        }\n        const rule = {\n            ruleId: ids[1],\n            replicationStatus: objectReplicationRecord[key],\n        };\n        const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);\n        if (policyIndex > -1) {\n            orProperties[policyIndex].rules.push(rule);\n        }\n        else {\n            orProperties.push({\n                policyId: ids[0],\n                rules: [rule],\n            });\n        }\n    }\n    return orProperties;\n}\n/**\n * Attach a TokenCredential to an object.\n *\n * @param thing -\n * @param credential -\n */\nexport function attachCredential(thing, credential) {\n    thing.credential = credential;\n    return thing;\n}\nexport function httpAuthorizationToString(httpAuthorization) {\n    return httpAuthorization ? httpAuthorization.scheme + \" \" + httpAuthorization.value : undefined;\n}\nexport function BlobNameToString(name) {\n    if (name.encoded) {\n        return decodeURIComponent(name.content);\n    }\n    else {\n        return name.content;\n    }\n}\nexport function ConvertInternalResponseOfListBlobFlat(internalResponse) {\n    return Object.assign(Object.assign({}, internalResponse), { segment: {\n            blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {\n                const blobItem = Object.assign(Object.assign({}, blobItemInteral), { name: BlobNameToString(blobItemInteral.name) });\n                return blobItem;\n            }),\n        } });\n}\nexport function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {\n    var _a;\n    return Object.assign(Object.assign({}, internalResponse), { segment: {\n            blobPrefixes: (_a = internalResponse.segment.blobPrefixes) === null || _a === void 0 ? void 0 : _a.map((blobPrefixInternal) => {\n                const blobPrefix = {\n                    name: BlobNameToString(blobPrefixInternal.name),\n                };\n                return blobPrefix;\n            }),\n            blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {\n                const blobItem = Object.assign(Object.assign({}, blobItemInteral), { name: BlobNameToString(blobItemInteral.name) });\n                return blobItem;\n            }),\n        } });\n}\nfunction decodeBase64String(value) {\n    if (isNode) {\n        return Buffer.from(value, \"base64\");\n    }\n    else {\n        const byteString = atob(value);\n        const arr = new Uint8Array(byteString.length);\n        for (let i = 0; i < byteString.length; i++) {\n            arr[i] = byteString.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction ParseBoolean(content) {\n    if (content === undefined)\n        return undefined;\n    if (content === \"true\")\n        return true;\n    if (content === \"false\")\n        return false;\n    return undefined;\n}\nfunction ParseBlobName(blobNameInXML) {\n    if (blobNameInXML[\"$\"] !== undefined && blobNameInXML[\"#\"] !== undefined) {\n        return {\n            encoded: ParseBoolean(blobNameInXML[\"$\"][\"Encoded\"]),\n            content: blobNameInXML[\"#\"],\n        };\n    }\n    else {\n        return {\n            encoded: false,\n            content: blobNameInXML,\n        };\n    }\n}\nfunction ParseBlobProperties(blobPropertiesInXML) {\n    const blobProperties = blobPropertiesInXML;\n    if (blobPropertiesInXML[\"Creation-Time\"]) {\n        blobProperties.createdOn = new Date(blobPropertiesInXML[\"Creation-Time\"]);\n        delete blobProperties[\"Creation-Time\"];\n    }\n    if (blobPropertiesInXML[\"Last-Modified\"]) {\n        blobProperties.lastModified = new Date(blobPropertiesInXML[\"Last-Modified\"]);\n        delete blobProperties[\"Last-Modified\"];\n    }\n    if (blobPropertiesInXML[\"Etag\"]) {\n        blobProperties.etag = blobPropertiesInXML[\"Etag\"];\n        delete blobProperties[\"Etag\"];\n    }\n    if (blobPropertiesInXML[\"Content-Length\"]) {\n        blobProperties.contentLength = parseFloat(blobPropertiesInXML[\"Content-Length\"]);\n        delete blobProperties[\"Content-Length\"];\n    }\n    if (blobPropertiesInXML[\"Content-Type\"]) {\n        blobProperties.contentType = blobPropertiesInXML[\"Content-Type\"];\n        delete blobProperties[\"Content-Type\"];\n    }\n    if (blobPropertiesInXML[\"Content-Encoding\"]) {\n        blobProperties.contentEncoding = blobPropertiesInXML[\"Content-Encoding\"];\n        delete blobProperties[\"Content-Encoding\"];\n    }\n    if (blobPropertiesInXML[\"Content-Language\"]) {\n        blobProperties.contentLanguage = blobPropertiesInXML[\"Content-Language\"];\n        delete blobProperties[\"Content-Language\"];\n    }\n    if (blobPropertiesInXML[\"Content-MD5\"]) {\n        blobProperties.contentMD5 = decodeBase64String(blobPropertiesInXML[\"Content-MD5\"]);\n        delete blobProperties[\"Content-MD5\"];\n    }\n    if (blobPropertiesInXML[\"Content-Disposition\"]) {\n        blobProperties.contentDisposition = blobPropertiesInXML[\"Content-Disposition\"];\n        delete blobProperties[\"Content-Disposition\"];\n    }\n    if (blobPropertiesInXML[\"Cache-Control\"]) {\n        blobProperties.cacheControl = blobPropertiesInXML[\"Cache-Control\"];\n        delete blobProperties[\"Cache-Control\"];\n    }\n    if (blobPropertiesInXML[\"x-ms-blob-sequence-number\"]) {\n        blobProperties.blobSequenceNumber = parseFloat(blobPropertiesInXML[\"x-ms-blob-sequence-number\"]);\n        delete blobProperties[\"x-ms-blob-sequence-number\"];\n    }\n    if (blobPropertiesInXML[\"BlobType\"]) {\n        blobProperties.blobType = blobPropertiesInXML[\"BlobType\"];\n        delete blobProperties[\"BlobType\"];\n    }\n    if (blobPropertiesInXML[\"LeaseStatus\"]) {\n        blobProperties.leaseStatus = blobPropertiesInXML[\"LeaseStatus\"];\n        delete blobProperties[\"LeaseStatus\"];\n    }\n    if (blobPropertiesInXML[\"LeaseState\"]) {\n        blobProperties.leaseState = blobPropertiesInXML[\"LeaseState\"];\n        delete blobProperties[\"LeaseState\"];\n    }\n    if (blobPropertiesInXML[\"LeaseDuration\"]) {\n        blobProperties.leaseDuration = blobPropertiesInXML[\"LeaseDuration\"];\n        delete blobProperties[\"LeaseDuration\"];\n    }\n    if (blobPropertiesInXML[\"CopyId\"]) {\n        blobProperties.copyId = blobPropertiesInXML[\"CopyId\"];\n        delete blobProperties[\"CopyId\"];\n    }\n    if (blobPropertiesInXML[\"CopyStatus\"]) {\n        blobProperties.copyStatus = blobPropertiesInXML[\"CopyStatus\"];\n        delete blobProperties[\"CopyStatus\"];\n    }\n    if (blobPropertiesInXML[\"CopySource\"]) {\n        blobProperties.copySource = blobPropertiesInXML[\"CopySource\"];\n        delete blobProperties[\"CopySource\"];\n    }\n    if (blobPropertiesInXML[\"CopyProgress\"]) {\n        blobProperties.copyProgress = blobPropertiesInXML[\"CopyProgress\"];\n        delete blobProperties[\"CopyProgress\"];\n    }\n    if (blobPropertiesInXML[\"CopyCompletionTime\"]) {\n        blobProperties.copyCompletedOn = new Date(blobPropertiesInXML[\"CopyCompletionTime\"]);\n        delete blobProperties[\"CopyCompletionTime\"];\n    }\n    if (blobPropertiesInXML[\"CopyStatusDescription\"]) {\n        blobProperties.copyStatusDescription = blobPropertiesInXML[\"CopyStatusDescription\"];\n        delete blobProperties[\"CopyStatusDescription\"];\n    }\n    if (blobPropertiesInXML[\"ServerEncrypted\"]) {\n        blobProperties.serverEncrypted = ParseBoolean(blobPropertiesInXML[\"ServerEncrypted\"]);\n        delete blobProperties[\"ServerEncrypted\"];\n    }\n    if (blobPropertiesInXML[\"IncrementalCopy\"]) {\n        blobProperties.incrementalCopy = ParseBoolean(blobPropertiesInXML[\"IncrementalCopy\"]);\n        delete blobProperties[\"IncrementalCopy\"];\n    }\n    if (blobPropertiesInXML[\"DestinationSnapshot\"]) {\n        blobProperties.destinationSnapshot = blobPropertiesInXML[\"DestinationSnapshot\"];\n        delete blobProperties[\"DestinationSnapshot\"];\n    }\n    if (blobPropertiesInXML[\"DeletedTime\"]) {\n        blobProperties.deletedOn = new Date(blobPropertiesInXML[\"DeletedTime\"]);\n        delete blobProperties[\"DeletedTime\"];\n    }\n    if (blobPropertiesInXML[\"RemainingRetentionDays\"]) {\n        blobProperties.remainingRetentionDays = parseFloat(blobPropertiesInXML[\"RemainingRetentionDays\"]);\n        delete blobProperties[\"RemainingRetentionDays\"];\n    }\n    if (blobPropertiesInXML[\"AccessTier\"]) {\n        blobProperties.accessTier = blobPropertiesInXML[\"AccessTier\"];\n        delete blobProperties[\"AccessTier\"];\n    }\n    if (blobPropertiesInXML[\"AccessTierInferred\"]) {\n        blobProperties.accessTierInferred = ParseBoolean(blobPropertiesInXML[\"AccessTierInferred\"]);\n        delete blobProperties[\"AccessTierInferred\"];\n    }\n    if (blobPropertiesInXML[\"ArchiveStatus\"]) {\n        blobProperties.archiveStatus = blobPropertiesInXML[\"ArchiveStatus\"];\n        delete blobProperties[\"ArchiveStatus\"];\n    }\n    if (blobPropertiesInXML[\"CustomerProvidedKeySha256\"]) {\n        blobProperties.customerProvidedKeySha256 = blobPropertiesInXML[\"CustomerProvidedKeySha256\"];\n        delete blobProperties[\"CustomerProvidedKeySha256\"];\n    }\n    if (blobPropertiesInXML[\"EncryptionScope\"]) {\n        blobProperties.encryptionScope = blobPropertiesInXML[\"EncryptionScope\"];\n        delete blobProperties[\"EncryptionScope\"];\n    }\n    if (blobPropertiesInXML[\"AccessTierChangeTime\"]) {\n        blobProperties.accessTierChangedOn = new Date(blobPropertiesInXML[\"AccessTierChangeTime\"]);\n        delete blobProperties[\"AccessTierChangeTime\"];\n    }\n    if (blobPropertiesInXML[\"TagCount\"]) {\n        blobProperties.tagCount = parseFloat(blobPropertiesInXML[\"TagCount\"]);\n        delete blobProperties[\"TagCount\"];\n    }\n    if (blobPropertiesInXML[\"Expiry-Time\"]) {\n        blobProperties.expiresOn = new Date(blobPropertiesInXML[\"Expiry-Time\"]);\n        delete blobProperties[\"Expiry-Time\"];\n    }\n    if (blobPropertiesInXML[\"Sealed\"]) {\n        blobProperties.isSealed = ParseBoolean(blobPropertiesInXML[\"Sealed\"]);\n        delete blobProperties[\"Sealed\"];\n    }\n    if (blobPropertiesInXML[\"RehydratePriority\"]) {\n        blobProperties.rehydratePriority = blobPropertiesInXML[\"RehydratePriority\"];\n        delete blobProperties[\"RehydratePriority\"];\n    }\n    if (blobPropertiesInXML[\"LastAccessTime\"]) {\n        blobProperties.lastAccessedOn = new Date(blobPropertiesInXML[\"LastAccessTime\"]);\n        delete blobProperties[\"LastAccessTime\"];\n    }\n    if (blobPropertiesInXML[\"ImmutabilityPolicyUntilDate\"]) {\n        blobProperties.immutabilityPolicyExpiresOn = new Date(blobPropertiesInXML[\"ImmutabilityPolicyUntilDate\"]);\n        delete blobProperties[\"ImmutabilityPolicyUntilDate\"];\n    }\n    if (blobPropertiesInXML[\"ImmutabilityPolicyMode\"]) {\n        blobProperties.immutabilityPolicyMode = blobPropertiesInXML[\"ImmutabilityPolicyMode\"];\n        delete blobProperties[\"ImmutabilityPolicyMode\"];\n    }\n    if (blobPropertiesInXML[\"LegalHold\"]) {\n        blobProperties.legalHold = ParseBoolean(blobPropertiesInXML[\"LegalHold\"]);\n        delete blobProperties[\"LegalHold\"];\n    }\n    return blobProperties;\n}\nfunction ParseBlobItem(blobInXML) {\n    const blobItem = blobInXML;\n    blobItem.properties = ParseBlobProperties(blobInXML[\"Properties\"]);\n    delete blobItem[\"Properties\"];\n    blobItem.name = ParseBlobName(blobInXML[\"Name\"]);\n    delete blobItem[\"Name\"];\n    blobItem.deleted = ParseBoolean(blobInXML[\"Deleted\"]);\n    delete blobItem[\"Deleted\"];\n    if (blobInXML[\"Snapshot\"]) {\n        blobItem.snapshot = blobInXML[\"Snapshot\"];\n        delete blobItem[\"Snapshot\"];\n    }\n    if (blobInXML[\"VersionId\"]) {\n        blobItem.versionId = blobInXML[\"VersionId\"];\n        delete blobItem[\"VersionId\"];\n    }\n    if (blobInXML[\"IsCurrentVersion\"]) {\n        blobItem.isCurrentVersion = ParseBoolean(blobInXML[\"IsCurrentVersion\"]);\n        delete blobItem[\"IsCurrentVersion\"];\n    }\n    if (blobInXML[\"Metadata\"]) {\n        blobItem.metadata = blobInXML[\"Metadata\"];\n        delete blobItem[\"Metadata\"];\n    }\n    if (blobInXML[\"Tags\"]) {\n        blobItem.blobTags = ParseBlobTags(blobInXML[\"Tags\"]);\n        delete blobItem[\"Tags\"];\n    }\n    if (blobInXML[\"OrMetadata\"]) {\n        blobItem.objectReplicationMetadata = blobInXML[\"OrMetadata\"];\n        delete blobItem[\"OrMetadata\"];\n    }\n    if (blobInXML[\"HasVersionsOnly\"]) {\n        blobItem.hasVersionsOnly = ParseBoolean(blobInXML[\"HasVersionsOnly\"]);\n        delete blobItem[\"HasVersionsOnly\"];\n    }\n    return blobItem;\n}\nfunction ParseBlobPrefix(blobPrefixInXML) {\n    return {\n        name: ParseBlobName(blobPrefixInXML[\"Name\"]),\n    };\n}\nfunction ParseBlobTag(blobTagInXML) {\n    return {\n        key: blobTagInXML[\"Key\"],\n        value: blobTagInXML[\"Value\"],\n    };\n}\nfunction ParseBlobTags(blobTagsInXML) {\n    if (blobTagsInXML === undefined ||\n        blobTagsInXML[\"TagSet\"] === undefined ||\n        blobTagsInXML[\"TagSet\"][\"Tag\"] === undefined) {\n        return undefined;\n    }\n    const blobTagSet = [];\n    if (blobTagsInXML[\"TagSet\"][\"Tag\"] instanceof Array) {\n        blobTagsInXML[\"TagSet\"][\"Tag\"].forEach((blobTagInXML) => {\n            blobTagSet.push(ParseBlobTag(blobTagInXML));\n        });\n    }\n    else {\n        blobTagSet.push(ParseBlobTag(blobTagsInXML[\"TagSet\"][\"Tag\"]));\n    }\n    return { blobTagSet: blobTagSet };\n}\nexport function ProcessBlobItems(blobArrayInXML) {\n    const blobItems = [];\n    if (blobArrayInXML instanceof Array) {\n        blobArrayInXML.forEach((blobInXML) => {\n            blobItems.push(ParseBlobItem(blobInXML));\n        });\n    }\n    else {\n        blobItems.push(ParseBlobItem(blobArrayInXML));\n    }\n    return blobItems;\n}\nexport function ProcessBlobPrefixes(blobPrefixesInXML) {\n    const blobPrefixes = [];\n    if (blobPrefixesInXML instanceof Array) {\n        blobPrefixesInXML.forEach((blobPrefixInXML) => {\n            blobPrefixes.push(ParseBlobPrefix(blobPrefixInXML));\n        });\n    }\n    else {\n        blobPrefixes.push(ParseBlobPrefix(blobPrefixesInXML));\n    }\n    return blobPrefixes;\n}\nexport function* ExtractPageRangeInfoItems(getPageRangesSegment) {\n    let pageRange = [];\n    let clearRange = [];\n    if (getPageRangesSegment.pageRange)\n        pageRange = getPageRangesSegment.pageRange;\n    if (getPageRangesSegment.clearRange)\n        clearRange = getPageRangesSegment.clearRange;\n    let pageRangeIndex = 0;\n    let clearRangeIndex = 0;\n    while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {\n        if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {\n            yield {\n                start: pageRange[pageRangeIndex].start,\n                end: pageRange[pageRangeIndex].end,\n                isClear: false,\n            };\n            ++pageRangeIndex;\n        }\n        else {\n            yield {\n                start: clearRange[clearRangeIndex].start,\n                end: clearRange[clearRangeIndex].end,\n                isClear: true,\n            };\n            ++clearRangeIndex;\n        }\n    }\n    for (; pageRangeIndex < pageRange.length; ++pageRangeIndex) {\n        yield {\n            start: pageRange[pageRangeIndex].start,\n            end: pageRange[pageRangeIndex].end,\n            isClear: false,\n        };\n    }\n    for (; clearRangeIndex < clearRange.length; ++clearRangeIndex) {\n        yield {\n            start: clearRange[clearRangeIndex].start,\n            end: clearRange[clearRangeIndex].end,\n            isClear: true,\n        };\n    }\n}\n//# sourceMappingURL=utils.common.js.map"]},"metadata":{},"sourceType":"module"}