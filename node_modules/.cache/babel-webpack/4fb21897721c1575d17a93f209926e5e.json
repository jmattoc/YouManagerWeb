{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Equipo/source/Tgsc-Proyectos/youManager-web/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { generateUuid, getDefaultProxySettings, isNode, isTokenCredential, URLBuilder } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { BlobDownloadResponse } from \"./BlobDownloadResponse\";\nimport { BlobQueryResponse } from \"./BlobQueryResponse\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AppendBlob, Blob as StorageBlob, BlockBlob, PageBlob } from \"./generated/src/operations\";\nimport { ensureCpkIfSpecified, toAccessTier } from \"./models\";\nimport { rangeResponseFromModel } from \"./PageBlobRangeResponse\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { BlobBeginCopyFromUrlPoller } from \"./pollers/BlobStartCopyFromUrlPoller\";\nimport { rangeToString } from \"./Range\";\nimport { StorageClient } from \"./StorageClient\";\nimport { Batch } from \"./utils/Batch\";\nimport { BufferScheduler } from \"../../storage-common/src\";\nimport { BlobDoesNotUseCustomerSpecifiedEncryption, BlobUsesCustomerSpecifiedEncryptionMsg, BLOCK_BLOB_MAX_BLOCKS, BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES, BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES, DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES, DEFAULT_BLOCK_BUFFER_SIZE_BYTES, DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS, ETagAny, URLConstants } from \"./utils/constants\";\nimport { createSpan, convertTracingToRequestOptionsBase } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, ExtractPageRangeInfoItems, generateBlockID, getURLParameter, httpAuthorizationToString, isIpEndpointStyle, parseObjectReplicationRecord, setURLParameter, toBlobTags, toBlobTagsString, toQuerySerialization, toTags } from \"./utils/utils.common\";\nimport { fsCreateReadStream, fsStat, readStreamToLocalFile, streamToBuffer } from \"./utils/utils.node\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\n/**\n * A BlobClient represents a URL to an Azure Storage blob; the blob may be a block blob,\n * append blob, or page blob.\n */\n\nexport class BlobClient extends StorageClient {\n  constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    options = options || {};\n    let pipeline;\n    let url;\n\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n\n    super(url, pipeline);\n    ({\n      blobName: this._name,\n      containerName: this._containerName\n    } = this.getBlobAndContainerNamesFromUrl());\n    this.blobContext = new StorageBlob(this.storageClientContext);\n    this._snapshot = getURLParameter(this.url, URLConstants.Parameters.SNAPSHOT);\n    this._versionId = getURLParameter(this.url, URLConstants.Parameters.VERSIONID);\n  }\n  /**\n   * The name of the blob.\n   */\n\n\n  get name() {\n    return this._name;\n  }\n  /**\n   * The name of the storage container the blob is associated with.\n   */\n\n\n  get containerName() {\n    return this._containerName;\n  }\n  /**\n   * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new BlobClient object identical to the source but with the specified snapshot timestamp\n   */\n\n\n  withSnapshot(snapshot) {\n    return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n  }\n  /**\n   * Creates a new BlobClient object pointing to a version of this blob.\n   * Provide \"\" will remove the versionId and return a Client to the base blob.\n   *\n   * @param versionId - The versionId.\n   * @returns A new BlobClient object pointing to the version of this blob.\n   */\n\n\n  withVersion(versionId) {\n    return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.VERSIONID, versionId.length === 0 ? undefined : versionId), this.pipeline);\n  }\n  /**\n   * Creates a AppendBlobClient object.\n   *\n   */\n\n\n  getAppendBlobClient() {\n    return new AppendBlobClient(this.url, this.pipeline);\n  }\n  /**\n   * Creates a BlockBlobClient object.\n   *\n   */\n\n\n  getBlockBlobClient() {\n    return new BlockBlobClient(this.url, this.pipeline);\n  }\n  /**\n   * Creates a PageBlobClient object.\n   *\n   */\n\n\n  getPageBlobClient() {\n    return new PageBlobClient(this.url, this.pipeline);\n  }\n  /**\n   * Reads or downloads a blob from the system, including its metadata and properties.\n   * You can also call Get Blob to read a snapshot.\n   *\n   * * In Node.js, data returns in a Readable stream readableStreamBody\n   * * In browsers, data returns in a promise blobBody\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob\n   *\n   * @param offset - From which position of the blob to download, greater than or equal to 0\n   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n   * @param options - Optional options to Blob Download operation.\n   *\n   *\n   * Example usage (Node.js):\n   *\n   * ```js\n   * // Download and convert a blob to a string\n   * const downloadBlockBlobResponse = await blobClient.download();\n   * const downloaded = await streamToBuffer(downloadBlockBlobResponse.readableStreamBody);\n   * console.log(\"Downloaded blob content:\", downloaded.toString());\n   *\n   * async function streamToBuffer(readableStream) {\n   * return new Promise((resolve, reject) => {\n   * const chunks = [];\n   * readableStream.on(\"data\", (data) => {\n   * chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   * });\n   * readableStream.on(\"end\", () => {\n   * resolve(Buffer.concat(chunks));\n   * });\n   * readableStream.on(\"error\", reject);\n   * });\n   * }\n   * ```\n   *\n   * Example usage (browser):\n   *\n   * ```js\n   * // Download and convert a blob to a string\n   * const downloadBlockBlobResponse = await blobClient.download();\n   * const downloaded = await blobToString(await downloadBlockBlobResponse.blobBody);\n   * console.log(\n   *   \"Downloaded blob content\",\n   *   downloaded\n   * );\n   *\n   * async function blobToString(blob: Blob): Promise<string> {\n   *   const fileReader = new FileReader();\n   *   return new Promise<string>((resolve, reject) => {\n   *     fileReader.onloadend = (ev: any) => {\n   *       resolve(ev.target!.result);\n   *     };\n   *     fileReader.onerror = reject;\n   *     fileReader.readAsText(blob);\n   *   });\n   * }\n   * ```\n   */\n\n\n  download(offset = 0, count, options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      options.conditions = options.conditions || {};\n      ensureCpkIfSpecified(options.customerProvidedKey, _this.isHttps);\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-download\", options);\n\n      try {\n        const res = yield _this.blobContext.download(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          requestOptions: {\n            onDownloadProgress: isNode ? undefined : options.onProgress // for Node.js, progress is reported by RetriableReadableStream\n\n          },\n          range: offset === 0 && !count ? undefined : rangeToString({\n            offset,\n            count\n          }),\n          rangeGetContentMD5: options.rangeGetContentMD5,\n          rangeGetContentCRC64: options.rangeGetContentCrc64,\n          snapshot: options.snapshot,\n          cpkInfo: options.customerProvidedKey\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        const wrappedRes = Object.assign(Object.assign({}, res), {\n          _response: res._response,\n          objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,\n          objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules)\n        }); // Return browser response immediately\n\n        if (!isNode) {\n          return wrappedRes;\n        } // We support retrying when download stream unexpected ends in Node.js runtime\n        // Following code shouldn't be bundled into browser build, however some\n        // bundlers may try to bundle following code and \"FileReadResponse.ts\".\n        // In this case, \"FileDownloadResponse.browser.ts\" will be used as a shim of \"FileDownloadResponse.ts\"\n        // The config is in package.json \"browser\" field\n\n\n        if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {\n          // TODO: Default value or make it a required parameter?\n          options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;\n        }\n\n        if (res.contentLength === undefined) {\n          throw new RangeError(`File download response doesn't contain valid content length header`);\n        }\n\n        if (!res.etag) {\n          throw new RangeError(`File download response doesn't contain valid etag header`);\n        }\n\n        return new BlobDownloadResponse(wrappedRes, /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (start) {\n            var _a;\n\n            const updatedDownloadOptions = {\n              leaseAccessConditions: options.conditions,\n              modifiedAccessConditions: {\n                ifMatch: options.conditions.ifMatch || res.etag,\n                ifModifiedSince: options.conditions.ifModifiedSince,\n                ifNoneMatch: options.conditions.ifNoneMatch,\n                ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,\n                ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n              },\n              range: rangeToString({\n                count: offset + res.contentLength - start,\n                offset: start\n              }),\n              rangeGetContentMD5: options.rangeGetContentMD5,\n              rangeGetContentCRC64: options.rangeGetContentCrc64,\n              snapshot: options.snapshot,\n              cpkInfo: options.customerProvidedKey\n            }; // Debug purpose only\n            // console.log(\n            //   `Read from internal stream, range: ${\n            //     updatedOptions.range\n            //   }, options: ${JSON.stringify(updatedOptions)}`\n            // );\n\n            return (yield _this.blobContext.download(Object.assign({\n              abortSignal: options.abortSignal\n            }, updatedDownloadOptions))).readableStreamBody;\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }(), offset, res.contentLength, {\n          maxRetryRequests: options.maxRetryRequests,\n          onProgress: options.onProgress\n        });\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns true if the Azure blob resource represented by this client exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing blob might be deleted by other clients or\n   * applications. Vice versa new blobs might be added by other clients or applications after this\n   * function completes.\n   *\n   * @param options - options to Exists operation.\n   */\n\n\n  exists(options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-exists\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this2.isHttps);\n        yield _this2.getProperties({\n          abortSignal: options.abortSignal,\n          customerProvidedKey: options.customerProvidedKey,\n          conditions: options.conditions,\n          tracingOptions: updatedOptions.tracingOptions\n        });\n        return true;\n      } catch (e) {\n        if (e.statusCode === 404) {\n          // Expected exception when checking blob existence\n          return false;\n        } else if (e.statusCode === 409 && (e.details.errorCode === BlobUsesCustomerSpecifiedEncryptionMsg || e.details.errorCode === BlobDoesNotUseCustomerSpecifiedEncryption)) {\n          // Expected exception when checking blob existence\n          return true;\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns all user-defined metadata, standard HTTP properties, and system properties\n   * for the blob. It does not return the content of the blob.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties\n   *\n   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n   * they originally contained uppercase characters. This differs from the metadata keys returned by\n   * the methods of {@link ContainerClient} that list blobs using the `includeMetadata` option, which\n   * will retain their original casing.\n   *\n   * @param options - Optional options to Get Properties operation.\n   */\n\n\n  getProperties(options = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-getProperties\", options);\n\n      try {\n        options.conditions = options.conditions || {};\n        ensureCpkIfSpecified(options.customerProvidedKey, _this3.isHttps);\n        const res = yield _this3.blobContext.getProperties(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        return Object.assign(Object.assign({}, res), {\n          _response: res._response,\n          objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,\n          objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules)\n        });\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Marks the specified blob or snapshot for deletion. The blob is later deleted\n   * during garbage collection. Note that in order to delete a blob, you must delete\n   * all of its snapshots. You can delete both at the same time with the Delete\n   * Blob operation.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n   *\n   * @param options - Optional options to Blob Delete operation.\n   */\n\n\n  delete(options = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-delete\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        return yield _this4.blobContext.delete(Object.assign({\n          abortSignal: options.abortSignal,\n          deleteSnapshots: options.deleteSnapshots,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Marks the specified blob or snapshot for deletion if it exists. The blob is later deleted\n   * during garbage collection. Note that in order to delete a blob, you must delete\n   * all of its snapshots. You can delete both at the same time with the Delete\n   * Blob operation.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n   *\n   * @param options - Optional options to Blob Delete operation.\n   */\n\n\n  deleteIfExists(options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-deleteIfExists\", options);\n\n      try {\n        const res = yield _this5.delete(updatedOptions);\n        return Object.assign(Object.assign({\n          succeeded: true\n        }, res), {\n          _response: res._response\n        });\n      } catch (e) {\n        if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobNotFound\") {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when deleting a blob or snapshot only if it exists.\"\n          });\n          return Object.assign(Object.assign({\n            succeeded: false\n          }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n            _response: e.response\n          });\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Restores the contents and metadata of soft deleted blob and any associated\n   * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29\n   * or later.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/undelete-blob\n   *\n   * @param options - Optional options to Blob Undelete operation.\n   */\n\n\n  undelete(options = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-undelete\", options);\n\n      try {\n        return yield _this6.blobContext.undelete(Object.assign({\n          abortSignal: options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets system properties on the blob.\n   *\n   * If no value provided, or no value provided for the specified blob HTTP headers,\n   * these blob HTTP headers without a value will be cleared.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n   *\n   * @param blobHTTPHeaders - If no value provided, or no value provided for\n   *                                                   the specified blob HTTP headers, these blob HTTP\n   *                                                   headers without a value will be cleared.\n   *                                                   A common header to set is `blobContentType`\n   *                                                   enabling the browser to provide functionality\n   *                                                   based on file type.\n   * @param options - Optional options to Blob Set HTTP Headers operation.\n   */\n\n\n  setHTTPHeaders(blobHTTPHeaders, options = {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setHTTPHeaders\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this7.isHttps);\n        return yield _this7.blobContext.setHttpHeaders(Object.assign({\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets user-defined metadata for the specified blob as one or more name-value pairs.\n   *\n   * If no option provided, or no metadata defined in the parameter, the blob\n   * metadata will be removed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata\n   *\n   * @param metadata - Replace existing metadata with this value.\n   *                               If no value provided the existing metadata will be removed.\n   * @param options - Optional options to Set Metadata operation.\n   */\n\n\n  setMetadata(metadata, options = {}) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setMetadata\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this8.isHttps);\n        return yield _this8.blobContext.setMetadata(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets tags on the underlying blob.\n   * A blob can have up to 10 tags. Tag keys must be between 1 and 128 characters.  Tag values must be between 0 and 256 characters.\n   * Valid tag key and value characters include lower and upper case letters, digits (0-9),\n   * space (' '), plus ('+'), minus ('-'), period ('.'), foward slash ('/'), colon (':'), equals ('='), and underscore ('_').\n   *\n   * @param tags -\n   * @param options -\n   */\n\n\n  setTags(tags, options = {}) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setTags\", options);\n\n      try {\n        return yield _this9.blobContext.setTags(Object.assign(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)), {\n          tags: toBlobTags(tags)\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Gets the tags associated with the underlying blob.\n   *\n   * @param options -\n   */\n\n\n  getTags(options = {}) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-getTags\", options);\n\n      try {\n        const response = yield _this10.blobContext.getTags(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        const wrappedResponse = Object.assign(Object.assign({}, response), {\n          _response: response._response,\n          tags: toTags({\n            blobTagSet: response.blobTagSet\n          }) || {}\n        });\n        return wrappedResponse;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Get a {@link BlobLeaseClient} that manages leases on the blob.\n   *\n   * @param proposeLeaseId - Initial proposed lease Id.\n   * @returns A new BlobLeaseClient object for managing leases on the blob.\n   */\n\n\n  getBlobLeaseClient(proposeLeaseId) {\n    return new BlobLeaseClient(this, proposeLeaseId);\n  }\n  /**\n   * Creates a read-only snapshot of a blob.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/snapshot-blob\n   *\n   * @param options - Optional options to the Blob Create Snapshot operation.\n   */\n\n\n  createSnapshot(options = {}) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-createSnapshot\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this11.isHttps);\n        return yield _this11.blobContext.createSnapshot(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Asynchronously copies a blob to a destination within the storage account.\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the copy is completed.\n   * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n   * a committed blob in any Azure storage account.\n   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n   * an Azure file in any Azure storage account.\n   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n   * operation to copy from another storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n   *\n   * Example using automatic polling:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url');\n   * const result = await copyPoller.pollUntilDone();\n   * ```\n   *\n   * Example using manual polling:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url');\n   * while (!poller.isDone()) {\n   *    await poller.poll();\n   * }\n   * const result = copyPoller.getResult();\n   * ```\n   *\n   * Example using progress updates:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url', {\n   *   onProgress(state) {\n   *     console.log(`Progress: ${state.copyProgress}`);\n   *   }\n   * });\n   * const result = await copyPoller.pollUntilDone();\n   * ```\n   *\n   * Example using a changing polling interval (default 15 seconds):\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url', {\n   *   intervalInMs: 1000 // poll blob every 1 second for copy progress\n   * });\n   * const result = await copyPoller.pollUntilDone();\n   * ```\n   *\n   * Example using copy cancellation:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url');\n   * // cancel operation after starting it.\n   * try {\n   *   await copyPoller.cancelOperation();\n   *   // calls to get the result now throw PollerCancelledError\n   *   await copyPoller.getResult();\n   * } catch (err) {\n   *   if (err.name === 'PollerCancelledError') {\n   *     console.log('The copy was cancelled.');\n   *   }\n   * }\n   * ```\n   *\n   * @param copySource - url to the source Azure Blob/File.\n   * @param options - Optional options to the Blob Start Copy From URL operation.\n   */\n\n\n  beginCopyFromURL(copySource, options = {}) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const client = {\n        abortCopyFromURL: (...args) => _this12.abortCopyFromURL(...args),\n        getProperties: (...args) => _this12.getProperties(...args),\n        startCopyFromURL: (...args) => _this12.startCopyFromURL(...args)\n      };\n      const poller = new BlobBeginCopyFromUrlPoller({\n        blobClient: client,\n        copySource,\n        intervalInMs: options.intervalInMs,\n        onProgress: options.onProgress,\n        resumeFrom: options.resumeFrom,\n        startCopyFromURLOptions: options\n      }); // Trigger the startCopyFromURL call by calling poll.\n      // Any errors from this method should be surfaced to the user.\n\n      yield poller.poll();\n      return poller;\n    })();\n  }\n  /**\n   * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero\n   * length and full metadata. Version 2012-02-12 and newer.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-blob\n   *\n   * @param copyId - Id of the Copy From URL operation.\n   * @param options - Optional options to the Blob Abort Copy From URL operation.\n   */\n\n\n  abortCopyFromURL(copyId, options = {}) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-abortCopyFromURL\", options);\n\n      try {\n        return yield _this13.blobContext.abortCopyFromURL(copyId, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not\n   * return a response until the copy is complete.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob-from-url\n   *\n   * @param copySource - The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication\n   * @param options -\n   */\n\n\n  syncCopyFromURL(copySource, options = {}) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-syncCopyFromURL\", options);\n      options.conditions = options.conditions || {};\n      options.sourceConditions = options.sourceConditions || {};\n\n      try {\n        return yield _this14.blobContext.copyFromURL(copySource, Object.assign({\n          abortSignal: options.abortSignal,\n          metadata: options.metadata,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: options.sourceConditions.ifMatch,\n            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n          },\n          sourceContentMD5: options.sourceContentMD5,\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n          blobTagsString: toBlobTagsString(options.tags),\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          encryptionScope: options.encryptionScope,\n          copySourceTags: options.copySourceTags\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets the tier on a blob. The operation is allowed on a page blob in a premium\n   * storage account and on a block blob in a blob storage account (locally redundant\n   * storage only). A premium page blob's tier determines the allowed size, IOPS,\n   * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive\n   * storage type. This operation does not update the blob's ETag.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-tier\n   *\n   * @param tier - The tier to be set on the blob. Valid values are Hot, Cool, or Archive.\n   * @param options - Optional options to the Blob Set Tier operation.\n   */\n\n\n  setAccessTier(tier, options = {}) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setAccessTier\", options);\n\n      try {\n        return yield _this15.blobContext.setTier(toAccessTier(tier), Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          rehydratePriority: options.rehydratePriority\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n  downloadToBuffer(param1, param2, param3, param4 = {}) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      let buffer;\n      let offset = 0;\n      let count = 0;\n      let options = param4;\n\n      if (param1 instanceof Buffer) {\n        buffer = param1;\n        offset = param2 || 0;\n        count = typeof param3 === \"number\" ? param3 : 0;\n      } else {\n        offset = typeof param1 === \"number\" ? param1 : 0;\n        count = typeof param2 === \"number\" ? param2 : 0;\n        options = param3 || {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-downloadToBuffer\", options);\n\n      try {\n        if (!options.blockSize) {\n          options.blockSize = 0;\n        }\n\n        if (options.blockSize < 0) {\n          throw new RangeError(\"blockSize option must be >= 0\");\n        }\n\n        if (options.blockSize === 0) {\n          options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n        }\n\n        if (offset < 0) {\n          throw new RangeError(\"offset option must be >= 0\");\n        }\n\n        if (count && count <= 0) {\n          throw new RangeError(\"count option must be greater than 0\");\n        }\n\n        if (!options.conditions) {\n          options.conditions = {};\n        } // Customer doesn't specify length, get it\n\n\n        if (!count) {\n          const response = yield _this16.getProperties(Object.assign(Object.assign({}, options), {\n            tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n          }));\n          count = response.contentLength - offset;\n\n          if (count < 0) {\n            throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);\n          }\n        } // Allocate the buffer of size = count if the buffer is not provided\n\n\n        if (!buffer) {\n          try {\n            buffer = Buffer.alloc(count);\n          } catch (error) {\n            throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the \"downloadToBuffer\" method or try using other methods like \"download\" or \"downloadToFile\".\\t ${error.message}`);\n          }\n        }\n\n        if (buffer.length < count) {\n          throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);\n        }\n\n        let transferProgress = 0;\n        const batch = new Batch(options.concurrency);\n\n        for (let off = offset; off < offset + count; off = off + options.blockSize) {\n          batch.addOperation( /*#__PURE__*/_asyncToGenerator(function* () {\n            // Exclusive chunk end position\n            let chunkEnd = offset + count;\n\n            if (off + options.blockSize < chunkEnd) {\n              chunkEnd = off + options.blockSize;\n            }\n\n            const response = yield _this16.download(off, chunkEnd - off, {\n              abortSignal: options.abortSignal,\n              conditions: options.conditions,\n              maxRetryRequests: options.maxRetryRequestsPerBlock,\n              customerProvidedKey: options.customerProvidedKey,\n              tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n            });\n            const stream = response.readableStreamBody;\n            yield streamToBuffer(stream, buffer, off - offset, chunkEnd - offset); // Update progress after block is downloaded, in case of block trying\n            // Could provide finer grained progress updating inside HTTP requests,\n            // only if convenience layer download try is enabled\n\n            transferProgress += chunkEnd - off;\n\n            if (options.onProgress) {\n              options.onProgress({\n                loadedBytes: transferProgress\n              });\n            }\n          }));\n        }\n\n        yield batch.do();\n        return buffer;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads an Azure Blob to a local file.\n   * Fails if the the given file path already exits.\n   * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.\n   *\n   * @param filePath -\n   * @param offset - From which position of the block blob to download.\n   * @param count - How much data to be downloaded. Will download to the end when passing undefined.\n   * @param options - Options to Blob download options.\n   * @returns The response data for blob download operation,\n   *                                                 but with readableStreamBody set to undefined since its\n   *                                                 content is already read and written into a local file\n   *                                                 at the specified path.\n   */\n\n\n  downloadToFile(filePath, offset = 0, count, options = {}) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-downloadToFile\", options);\n\n      try {\n        const response = yield _this17.download(offset, count, Object.assign(Object.assign({}, options), {\n          tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n        }));\n\n        if (response.readableStreamBody) {\n          yield readStreamToLocalFile(response.readableStreamBody, filePath);\n        } // The stream is no longer accessible so setting it to undefined.\n\n\n        response.blobDownloadStream = undefined;\n        return response;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n  getBlobAndContainerNamesFromUrl() {\n    let containerName;\n    let blobName;\n\n    try {\n      //  URL may look like the following\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob?sasString\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt?sasString\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt\";\n      // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername/blob`\n      // http://localhost:10001/devstoreaccount1/containername/blob\n      const parsedUrl = URLBuilder.parse(this.url);\n\n      if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n        // \"https://myaccount.blob.core.windows.net/containername/blob\".\n        // .getPath() -> /containername/blob\n        const pathComponents = parsedUrl.getPath().match(\"/([^/]*)(/(.*))?\");\n        containerName = pathComponents[1];\n        blobName = pathComponents[3];\n      } else if (isIpEndpointStyle(parsedUrl)) {\n        // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername/blob\n        // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername/blob\n        // .getPath() -> /devstoreaccount1/containername/blob\n        const pathComponents = parsedUrl.getPath().match(\"/([^/]*)/([^/]*)(/(.*))?\");\n        containerName = pathComponents[2];\n        blobName = pathComponents[4];\n      } else {\n        // \"https://customdomain.com/containername/blob\".\n        // .getPath() -> /containername/blob\n        const pathComponents = parsedUrl.getPath().match(\"/([^/]*)(/(.*))?\");\n        containerName = pathComponents[1];\n        blobName = pathComponents[3];\n      } // decode the encoded blobName, containerName - to get all the special characters that might be present in them\n\n\n      containerName = decodeURIComponent(containerName);\n      blobName = decodeURIComponent(blobName); // Azure Storage Server will replace \"\\\" with \"/\" in the blob names\n      //   doing the same in the SDK side so that the user doesn't have to replace \"\\\" instances in the blobName\n\n      blobName = blobName.replace(/\\\\/g, \"/\");\n\n      if (!containerName) {\n        throw new Error(\"Provided containerName is invalid.\");\n      }\n\n      return {\n        blobName,\n        containerName\n      };\n    } catch (error) {\n      throw new Error(\"Unable to extract blobName and containerName with provided information.\");\n    }\n  }\n  /**\n   * Asynchronously copies a blob to a destination within the storage account.\n   * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n   * a committed blob in any Azure storage account.\n   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n   * an Azure file in any Azure storage account.\n   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n   * operation to copy from another storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n   *\n   * @param copySource - url to the source Azure Blob/File.\n   * @param options - Optional options to the Blob Start Copy From URL operation.\n   */\n\n\n  startCopyFromURL(copySource, options = {}) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-startCopyFromURL\", options);\n      options.conditions = options.conditions || {};\n      options.sourceConditions = options.sourceConditions || {};\n\n      try {\n        return yield _this18.blobContext.startCopyFromURL(copySource, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: options.sourceConditions.ifMatch,\n            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n            sourceIfTags: options.sourceConditions.tagConditions\n          },\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          rehydratePriority: options.rehydratePriority,\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags),\n          sealBlob: options.sealBlob\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Only available for BlobClient constructed with a shared key credential.\n   *\n   * Generates a Blob Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n\n\n  generateSasUrl(options) {\n    return new Promise(resolve => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw new RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n      }\n\n      const sas = generateBlobSASQueryParameters(Object.assign({\n        containerName: this._containerName,\n        blobName: this._name,\n        snapshotTime: this._snapshot,\n        versionId: this._versionId\n      }, options), this.credential).toString();\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n  /**\n   * Delete the immutablility policy on the blob.\n   *\n   * @param options - Optional options to delete immutability policy on the blob.\n   */\n\n\n  deleteImmutabilityPolicy(options) {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-deleteImmutabilityPolicy\", options);\n\n      try {\n        return yield _this19.blobContext.deleteImmutabilityPolicy(Object.assign({\n          abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Set immutablility policy on the blob.\n   *\n   * @param options - Optional options to set immutability policy on the blob.\n   */\n\n\n  setImmutabilityPolicy(immutabilityPolicy, options) {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setImmutabilityPolicy\", options);\n\n      try {\n        return yield _this20.blobContext.setImmutabilityPolicy(Object.assign({\n          abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,\n          immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,\n          immutabilityPolicyMode: immutabilityPolicy.policyMode,\n          modifiedAccessConditions: options === null || options === void 0 ? void 0 : options.modifiedAccessCondition\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Set legal hold on the blob.\n   *\n   * @param options - Optional options to set legal hold on the blob.\n   */\n\n\n  setLegalHold(legalHoldEnabled, options) {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setLegalHold\", options);\n\n      try {\n        return yield _this21.blobContext.setLegalHold(legalHoldEnabled, Object.assign({\n          abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n}\n/**\n * AppendBlobClient defines a set of operations applicable to append blobs.\n */\n\nexport class AppendBlobClient extends BlobClient {\n  constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    let pipeline;\n    let url;\n    options = options || {};\n\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)      url = urlOrConnectionString;\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString; // The second parameter is undefined. Use anonymous credential.\n\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n\n    super(url, pipeline);\n    this.appendBlobContext = new AppendBlob(this.storageClientContext);\n  }\n  /**\n   * Creates a new AppendBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n\n\n  withSnapshot(snapshot) {\n    return new AppendBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n  }\n  /**\n   * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param options - Options to the Append Block Create operation.\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const appendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n   * await appendBlobClient.create();\n   * ```\n   */\n\n\n  create(options = {}) {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"AppendBlobClient-create\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this22.isHttps);\n        return yield _this22.appendBlobContext.create(0, Object.assign({\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          blobTagsString: toBlobTagsString(options.tags)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n   * If the blob with the same name already exists, the content of the existing blob will remain unchanged.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param options -\n   */\n\n\n  createIfNotExists(options = {}) {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"AppendBlobClient-createIfNotExists\", options);\n      const conditions = {\n        ifNoneMatch: ETagAny\n      };\n\n      try {\n        const res = yield _this23.create(Object.assign(Object.assign({}, updatedOptions), {\n          conditions\n        }));\n        return Object.assign(Object.assign({\n          succeeded: true\n        }, res), {\n          _response: res._response\n        });\n      } catch (e) {\n        if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobAlreadyExists\") {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when creating a blob only if it does not already exist.\"\n          });\n          return Object.assign(Object.assign({\n            succeeded: false\n          }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n            _response: e.response\n          });\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Seals the append blob, making it read only.\n   *\n   * @param options -\n   */\n\n\n  seal(options = {}) {\n    var _this24 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"AppendBlobClient-seal\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        return yield _this24.appendBlobContext.seal(Object.assign({\n          abortSignal: options.abortSignal,\n          appendPositionAccessConditions: options.conditions,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Commits a new block of data to the end of the existing append blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/append-block\n   *\n   * @param body - Data to be appended.\n   * @param contentLength - Length of the body in bytes.\n   * @param options - Options to the Append Block operation.\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello World!\";\n   *\n   * // Create a new append blob and append data to the blob.\n   * const newAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n   * await newAppendBlobClient.create();\n   * await newAppendBlobClient.appendBlock(content, content.length);\n   *\n   * // Append data to an existing append blob.\n   * const existingAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n   * await existingAppendBlobClient.appendBlock(content, content.length);\n   * ```\n   */\n\n\n  appendBlock(body, contentLength, options = {}) {\n    var _this25 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"AppendBlobClient-appendBlock\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this25.isHttps);\n        return yield _this25.appendBlobContext.appendBlock(contentLength, body, Object.assign({\n          abortSignal: options.abortSignal,\n          appendPositionAccessConditions: options.conditions,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          requestOptions: {\n            onUploadProgress: options.onProgress\n          },\n          transactionalContentMD5: options.transactionalContentMD5,\n          transactionalContentCrc64: options.transactionalContentCrc64,\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * The Append Block operation commits a new block of data to the end of an existing append blob\n   * where the contents are read from a source url.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/append-block-from-url\n   *\n   * @param sourceURL -\n   *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can\n   *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob\n   *                 must either be public or must be authenticated via a shared access signature. If the source blob is\n   *                 public, no authentication is required to perform the operation.\n   * @param sourceOffset - Offset in source to be appended\n   * @param count - Number of bytes to be appended as a block\n   * @param options -\n   */\n\n\n  appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {\n    var _this26 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"AppendBlobClient-appendBlockFromURL\", options);\n      options.conditions = options.conditions || {};\n      options.sourceConditions = options.sourceConditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this26.isHttps);\n        return yield _this26.appendBlobContext.appendBlockFromUrl(sourceURL, 0, Object.assign({\n          abortSignal: options.abortSignal,\n          sourceRange: rangeToString({\n            offset: sourceOffset,\n            count\n          }),\n          sourceContentMD5: options.sourceContentMD5,\n          sourceContentCrc64: options.sourceContentCrc64,\n          leaseAccessConditions: options.conditions,\n          appendPositionAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: options.sourceConditions.ifMatch,\n            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n          },\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n}\n/**\n * BlockBlobClient defines a set of operations applicable to block blobs.\n */\n\nexport class BlockBlobClient extends BlobClient {\n  constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    let pipeline;\n    let url;\n    options = options || {};\n\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n\n    super(url, pipeline);\n    this.blockBlobContext = new BlockBlob(this.storageClientContext);\n    this._blobContext = new StorageBlob(this.storageClientContext);\n  }\n  /**\n   * Creates a new BlockBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a URL to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n\n\n  withSnapshot(snapshot) {\n    return new BlockBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n  }\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Quick query for a JSON or CSV formatted blob.\n   *\n   * Example usage (Node.js):\n   *\n   * ```js\n   * // Query and convert a blob to a string\n   * const queryBlockBlobResponse = await blockBlobClient.query(\"select * from BlobStorage\");\n   * const downloaded = (await streamToBuffer(queryBlockBlobResponse.readableStreamBody)).toString();\n   * console.log(\"Query blob content:\", downloaded);\n   *\n   * async function streamToBuffer(readableStream) {\n   *   return new Promise((resolve, reject) => {\n   *     const chunks = [];\n   *     readableStream.on(\"data\", (data) => {\n   *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   *     });\n   *     readableStream.on(\"end\", () => {\n   *       resolve(Buffer.concat(chunks));\n   *     });\n   *     readableStream.on(\"error\", reject);\n   *   });\n   * }\n   * ```\n   *\n   * @param query -\n   * @param options -\n   */\n\n\n  query(query, options = {}) {\n    var _this27 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      ensureCpkIfSpecified(options.customerProvidedKey, _this27.isHttps);\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-query\", options);\n\n      try {\n        if (!isNode) {\n          throw new Error(\"This operation currently is only supported in Node.js.\");\n        }\n\n        ensureCpkIfSpecified(options.customerProvidedKey, _this27.isHttps);\n        const response = yield _this27._blobContext.query(Object.assign({\n          abortSignal: options.abortSignal,\n          queryRequest: {\n            queryType: \"SQL\",\n            expression: query,\n            inputSerialization: toQuerySerialization(options.inputTextConfiguration),\n            outputSerialization: toQuerySerialization(options.outputTextConfiguration)\n          },\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        return new BlobQueryResponse(response, {\n          abortSignal: options.abortSignal,\n          onProgress: options.onProgress,\n          onError: options.onError\n        });\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a new block blob, or updates the content of an existing block blob.\n   * Updating an existing block blob overwrites any existing metadata on the blob.\n   * Partial updates are not supported; the content of the existing blob is\n   * overwritten with the new content. To perform a partial update of a block blob's,\n   * use {@link stageBlock} and {@link commitBlockList}.\n   *\n   * This is a non-parallel uploading method, please use {@link uploadFile},\n   * {@link uploadStream} or {@link uploadBrowserData} for better performance\n   * with concurrency uploading.\n   *\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n   *                               which returns a new Readable stream whose offset is from data source beginning.\n   * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n   *                               string including non non-Base64/Hex-encoded characters.\n   * @param options - Options to the Block Blob Upload operation.\n   * @returns Response data for the Block Blob Upload operation.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\";\n   * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n   * ```\n   */\n\n\n  upload(body, contentLength, options = {}) {\n    var _this28 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-upload\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this28.isHttps);\n        return yield _this28.blockBlobContext.upload(contentLength, body, Object.assign({\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          requestOptions: {\n            onUploadProgress: options.onProgress\n          },\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a new Block Blob where the contents of the blob are read from a given URL.\n   * This API is supported beginning with the 2020-04-08 version. Partial updates\n   * are not supported with Put Blob from URL; the content of an existing blob is overwritten with\n   * the content of the new blob.  To perform partial updates to a block blobs contents using a\n   * source URL, use {@link stageBlockFromURL} and {@link commitBlockList}.\n   *\n   * @param sourceURL - Specifies the URL of the blob. The value\n   *                           may be a URL of up to 2 KB in length that specifies a blob.\n   *                           The value should be URL-encoded as it would appear\n   *                           in a request URI. The source blob must either be public\n   *                           or must be authenticated via a shared access signature.\n   *                           If the source blob is public, no authentication is required\n   *                           to perform the operation. Here are some examples of source object URLs:\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n   * @param options - Optional parameters.\n   */\n\n\n  syncUploadFromURL(sourceURL, options = {}) {\n    var _this29 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c, _d, _e;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-syncUploadFromURL\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this29.isHttps);\n        return yield _this29.blockBlobContext.putBlobFromUrl(0, sourceURL, Object.assign(Object.assign(Object.assign({}, options), {\n          blobHttpHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: options.conditions.tagConditions\n          }),\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: (_a = options.sourceConditions) === null || _a === void 0 ? void 0 : _a.ifMatch,\n            sourceIfModifiedSince: (_b = options.sourceConditions) === null || _b === void 0 ? void 0 : _b.ifModifiedSince,\n            sourceIfNoneMatch: (_c = options.sourceConditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch,\n            sourceIfUnmodifiedSince: (_d = options.sourceConditions) === null || _d === void 0 ? void 0 : _d.ifUnmodifiedSince,\n            sourceIfTags: (_e = options.sourceConditions) === null || _e === void 0 ? void 0 : _e.tagConditions\n          },\n          cpkInfo: options.customerProvidedKey,\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags),\n          copySourceTags: options.copySourceTags\n        }), convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Uploads the specified block to the block blob's \"staging area\" to be later\n   * committed by a call to commitBlockList.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-block\n   *\n   * @param blockId - A 64-byte value that is base64-encoded\n   * @param body - Data to upload to the staging area.\n   * @param contentLength - Number of bytes to upload.\n   * @param options - Options to the Block Blob Stage Block operation.\n   * @returns Response data for the Block Blob Stage Block operation.\n   */\n\n\n  stageBlock(blockId, body, contentLength, options = {}) {\n    var _this30 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-stageBlock\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this30.isHttps);\n        return yield _this30.blockBlobContext.stageBlock(blockId, contentLength, body, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          requestOptions: {\n            onUploadProgress: options.onProgress\n          },\n          transactionalContentMD5: options.transactionalContentMD5,\n          transactionalContentCrc64: options.transactionalContentCrc64,\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * The Stage Block From URL operation creates a new block to be committed as part\n   * of a blob where the contents are read from a URL.\n   * This API is available starting in version 2018-03-28.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-block-from-url\n   *\n   * @param blockId - A 64-byte value that is base64-encoded\n   * @param sourceURL - Specifies the URL of the blob. The value\n   *                           may be a URL of up to 2 KB in length that specifies a blob.\n   *                           The value should be URL-encoded as it would appear\n   *                           in a request URI. The source blob must either be public\n   *                           or must be authenticated via a shared access signature.\n   *                           If the source blob is public, no authentication is required\n   *                           to perform the operation. Here are some examples of source object URLs:\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n   * @param offset - From which position of the blob to download, greater than or equal to 0\n   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n   * @param options - Options to the Block Blob Stage Block From URL operation.\n   * @returns Response data for the Block Blob Stage Block From URL operation.\n   */\n\n\n  stageBlockFromURL(blockId, sourceURL, offset = 0, count, options = {}) {\n    var _this31 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-stageBlockFromURL\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this31.isHttps);\n        return yield _this31.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          sourceContentMD5: options.sourceContentMD5,\n          sourceContentCrc64: options.sourceContentCrc64,\n          sourceRange: offset === 0 && !count ? undefined : rangeToString({\n            offset,\n            count\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Writes a blob by specifying the list of block IDs that make up the blob.\n   * In order to be written as part of a blob, a block must have been successfully written\n   * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to\n   * update a blob by uploading only those blocks that have changed, then committing the new and existing\n   * blocks together. Any blocks not specified in the block list and permanently deleted.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-block-list\n   *\n   * @param blocks -  Array of 64-byte value that is base64-encoded\n   * @param options - Options to the Block Blob Commit Block List operation.\n   * @returns Response data for the Block Blob Commit Block List operation.\n   */\n\n\n  commitBlockList(blocks, options = {}) {\n    var _this32 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-commitBlockList\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this32.isHttps);\n        return yield _this32.blockBlobContext.commitBlockList({\n          latest: blocks\n        }, Object.assign({\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns the list of blocks that have been uploaded as part of a block blob\n   * using the specified block list filter.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-block-list\n   *\n   * @param listType - Specifies whether to return the list of committed blocks,\n   *                                        the list of uncommitted blocks, or both lists together.\n   * @param options - Options to the Block Blob Get Block List operation.\n   * @returns Response data for the Block Blob Get Block List operation.\n   */\n\n\n  getBlockList(listType, options = {}) {\n    var _this33 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-getBlockList\", options);\n\n      try {\n        const res = yield _this33.blockBlobContext.getBlockList(listType, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n\n        if (!res.committedBlocks) {\n          res.committedBlocks = [];\n        }\n\n        if (!res.uncommittedBlocks) {\n          res.uncommittedBlocks = [];\n        }\n\n        return res;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  } // High level functions\n\n  /**\n   * Uploads a Buffer(Node.js)/Blob(browsers)/ArrayBuffer/ArrayBufferView object to a BlockBlob.\n   *\n   * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n   * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n   * to commit the block list.\n   *\n   * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n   * `blobContentType`, enabling the browser to provide\n   * functionality based on file type.\n   *\n   * @param data - Buffer(Node.js), Blob, ArrayBuffer or ArrayBufferView\n   * @param options -\n   */\n\n\n  uploadData(data, options = {}) {\n    var _this34 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-uploadData\", options);\n\n      try {\n        if (isNode) {\n          let buffer;\n\n          if (data instanceof Buffer) {\n            buffer = data;\n          } else if (data instanceof ArrayBuffer) {\n            buffer = Buffer.from(data);\n          } else {\n            data = data;\n            buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n          }\n\n          return _this34.uploadSeekableInternal((offset, size) => buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);\n        } else {\n          const browserBlob = new Blob([data]);\n          return _this34.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);\n        }\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * ONLY AVAILABLE IN BROWSERS.\n   *\n   * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.\n   *\n   * When buffer length lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call\n   * {@link commitBlockList} to commit the block list.\n   *\n   * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n   * `blobContentType`, enabling the browser to provide\n   * functionality based on file type.\n   *\n   * @deprecated Use {@link uploadData} instead.\n   *\n   * @param browserData - Blob, File, ArrayBuffer or ArrayBufferView\n   * @param options - Options to upload browser data.\n   * @returns Response data for the Blob Upload operation.\n   */\n\n\n  uploadBrowserData(browserData, options = {}) {\n    var _this35 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-uploadBrowserData\", options);\n\n      try {\n        const browserBlob = new Blob([browserData]);\n        return yield _this35.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   *\n   * Uploads data to block blob. Requires a bodyFactory as the data source,\n   * which need to return a {@link HttpRequestBody} object with the offset and size provided.\n   *\n   * When data length is no more than the specified {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n   * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n   * to commit the block list.\n   *\n   * @param bodyFactory -\n   * @param size - size of the data to upload.\n   * @param options - Options to Upload to Block Blob operation.\n   * @returns Response data for the Blob Upload operation.\n   */\n\n\n  uploadSeekableInternal(bodyFactory, size, options = {}) {\n    var _this36 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.blockSize) {\n        options.blockSize = 0;\n      }\n\n      if (options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {\n        throw new RangeError(`blockSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);\n      }\n\n      if (options.maxSingleShotSize !== 0 && !options.maxSingleShotSize) {\n        options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;\n      }\n\n      if (options.maxSingleShotSize < 0 || options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {\n        throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);\n      }\n\n      if (options.blockSize === 0) {\n        if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS) {\n          throw new RangeError(`${size} is too larger to upload to a block blob.`);\n        }\n\n        if (size > options.maxSingleShotSize) {\n          options.blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);\n\n          if (options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {\n            options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n          }\n        }\n      }\n\n      if (!options.blobHTTPHeaders) {\n        options.blobHTTPHeaders = {};\n      }\n\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-uploadSeekableInternal\", options);\n\n      try {\n        if (size <= options.maxSingleShotSize) {\n          return yield _this36.upload(bodyFactory(0, size), size, updatedOptions);\n        }\n\n        const numBlocks = Math.floor((size - 1) / options.blockSize) + 1;\n\n        if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {\n          throw new RangeError(`The buffer's size is too big or the BlockSize is too small;` + `the number of blocks must be <= ${BLOCK_BLOB_MAX_BLOCKS}`);\n        }\n\n        const blockList = [];\n        const blockIDPrefix = generateUuid();\n        let transferProgress = 0;\n        const batch = new Batch(options.concurrency);\n\n        for (let i = 0; i < numBlocks; i++) {\n          batch.addOperation( /*#__PURE__*/_asyncToGenerator(function* () {\n            const blockID = generateBlockID(blockIDPrefix, i);\n            const start = options.blockSize * i;\n            const end = i === numBlocks - 1 ? size : start + options.blockSize;\n            const contentLength = end - start;\n            blockList.push(blockID);\n            yield _this36.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {\n              abortSignal: options.abortSignal,\n              conditions: options.conditions,\n              encryptionScope: options.encryptionScope,\n              tracingOptions: updatedOptions.tracingOptions\n            }); // Update progress after block is successfully uploaded to server, in case of block trying\n            // TODO: Hook with convenience layer progress event in finer level\n\n            transferProgress += contentLength;\n\n            if (options.onProgress) {\n              options.onProgress({\n                loadedBytes: transferProgress\n              });\n            }\n          }));\n        }\n\n        yield batch.do();\n        return _this36.commitBlockList(blockList, updatedOptions);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a local file in blocks to a block blob.\n   *\n   * When file size lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n   * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList\n   * to commit the block list.\n   *\n   * @param filePath - Full path of local file\n   * @param options - Options to Upload to Block Blob operation.\n   * @returns Response data for the Blob Upload operation.\n   */\n\n\n  uploadFile(filePath, options = {}) {\n    var _this37 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-uploadFile\", options);\n\n      try {\n        const size = (yield fsStat(filePath)).size;\n        return yield _this37.uploadSeekableInternal((offset, count) => {\n          return () => fsCreateReadStream(filePath, {\n            autoClose: true,\n            end: count ? offset + count - 1 : Infinity,\n            start: offset\n          });\n        }, size, Object.assign(Object.assign({}, options), {\n          tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a Node.js Readable stream into block blob.\n   *\n   * PERFORMANCE IMPROVEMENT TIPS:\n   * * Input stream highWaterMark is better to set a same value with bufferSize\n   *    parameter, which will avoid Buffer.concat() operations.\n   *\n   * @param stream - Node.js Readable stream\n   * @param bufferSize - Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB\n   * @param maxConcurrency -  Max concurrency indicates the max number of buffers that can be allocated,\n   *                                 positive correlation with max uploading concurrency. Default value is 5\n   * @param options - Options to Upload Stream to Block Blob operation.\n   * @returns Response data for the Blob Upload operation.\n   */\n\n\n  uploadStream(stream, bufferSize = DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {\n    var _this38 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.blobHTTPHeaders) {\n        options.blobHTTPHeaders = {};\n      }\n\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-uploadStream\", options);\n\n      try {\n        let blockNum = 0;\n        const blockIDPrefix = generateUuid();\n        let transferProgress = 0;\n        const blockList = [];\n        const scheduler = new BufferScheduler(stream, bufferSize, maxConcurrency, /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* (body, length) {\n            const blockID = generateBlockID(blockIDPrefix, blockNum);\n            blockList.push(blockID);\n            blockNum++;\n            yield _this38.stageBlock(blockID, body, length, {\n              conditions: options.conditions,\n              encryptionScope: options.encryptionScope,\n              tracingOptions: updatedOptions.tracingOptions\n            }); // Update progress after block is successfully uploaded to server, in case of block trying\n\n            transferProgress += length;\n\n            if (options.onProgress) {\n              options.onProgress({\n                loadedBytes: transferProgress\n              });\n            }\n          });\n\n          return function (_x2, _x3) {\n            return _ref4.apply(this, arguments);\n          };\n        }(), // concurrency should set a smaller value than maxConcurrency, which is helpful to\n        // reduce the possibility when a outgoing handler waits for stream data, in\n        // this situation, outgoing handlers are blocked.\n        // Outgoing queue shouldn't be empty.\n        Math.ceil(maxConcurrency / 4 * 3));\n        yield scheduler.do();\n        return yield _this38.commitBlockList(blockList, Object.assign(Object.assign({}, options), {\n          tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n}\n/**\n * PageBlobClient defines a set of operations applicable to page blobs.\n */\n\nexport class PageBlobClient extends BlobClient {\n  constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    let pipeline;\n    let url;\n    options = options || {};\n\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n\n    super(url, pipeline);\n    this.pageBlobContext = new PageBlob(this.storageClientContext);\n  }\n  /**\n   * Creates a new PageBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new PageBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n\n\n  withSnapshot(snapshot) {\n    return new PageBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n  }\n  /**\n   * Creates a page blob of the specified length. Call uploadPages to upload data\n   * data to a page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param size - size of the page blob.\n   * @param options - Options to the Page Blob Create operation.\n   * @returns Response data for the Page Blob Create operation.\n   */\n\n\n  create(size, options = {}) {\n    var _this39 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-create\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this39.isHttps);\n        return yield _this39.pageBlobContext.create(0, size, Object.assign({\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: options.blobHTTPHeaders,\n          blobSequenceNumber: options.blobSequenceNumber,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a page blob of the specified length. Call uploadPages to upload data\n   * data to a page blob. If the blob with the same name already exists, the content\n   * of the existing blob will remain unchanged.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param size - size of the page blob.\n   * @param options -\n   */\n\n\n  createIfNotExists(size, options = {}) {\n    var _this40 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-createIfNotExists\", options);\n\n      try {\n        const conditions = {\n          ifNoneMatch: ETagAny\n        };\n        const res = yield _this40.create(size, Object.assign(Object.assign({}, options), {\n          conditions,\n          tracingOptions: updatedOptions.tracingOptions\n        }));\n        return Object.assign(Object.assign({\n          succeeded: true\n        }, res), {\n          _response: res._response\n        });\n      } catch (e) {\n        if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobAlreadyExists\") {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when creating a blob only if it does not already exist.\"\n          });\n          return Object.assign(Object.assign({\n            succeeded: false\n          }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n            _response: e.response\n          });\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n   *\n   * @param body - Data to upload\n   * @param offset - Offset of destination page blob\n   * @param count - Content length of the body, also number of bytes to be uploaded\n   * @param options - Options to the Page Blob Upload Pages operation.\n   * @returns Response data for the Page Blob Upload Pages operation.\n   */\n\n\n  uploadPages(body, offset, count, options = {}) {\n    var _this41 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-uploadPages\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this41.isHttps);\n        return yield _this41.pageBlobContext.uploadPages(count, body, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          requestOptions: {\n            onUploadProgress: options.onProgress\n          },\n          range: rangeToString({\n            offset,\n            count\n          }),\n          sequenceNumberAccessConditions: options.conditions,\n          transactionalContentMD5: options.transactionalContentMD5,\n          transactionalContentCrc64: options.transactionalContentCrc64,\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * The Upload Pages operation writes a range of pages to a page blob where the\n   * contents are read from a URL.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-page-from-url\n   *\n   * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication\n   * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source page blob\n   * @param destOffset - Offset of destination page blob\n   * @param count - Number of bytes to be uploaded from source page blob\n   * @param options -\n   */\n\n\n  uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {\n    var _this42 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      options.sourceConditions = options.sourceConditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-uploadPagesFromURL\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this42.isHttps);\n        return yield _this42.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({\n          offset: sourceOffset,\n          count\n        }), 0, rangeToString({\n          offset: destOffset,\n          count\n        }), Object.assign({\n          abortSignal: options.abortSignal,\n          sourceContentMD5: options.sourceContentMD5,\n          sourceContentCrc64: options.sourceContentCrc64,\n          leaseAccessConditions: options.conditions,\n          sequenceNumberAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: options.sourceConditions.ifMatch,\n            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n          },\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Frees the specified pages from the page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n   *\n   * @param offset - Starting byte position of the pages to clear.\n   * @param count - Number of bytes to clear.\n   * @param options - Options to the Page Blob Clear Pages operation.\n   * @returns Response data for the Page Blob Clear Pages operation.\n   */\n\n\n  clearPages(offset = 0, count, options = {}) {\n    var _this43 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-clearPages\", options);\n\n      try {\n        return yield _this43.pageBlobContext.clearPages(0, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          range: rangeToString({\n            offset,\n            count\n          }),\n          sequenceNumberAccessConditions: options.conditions,\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns the list of valid page ranges for a page blob or snapshot of a page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param options - Options to the Page Blob Get Ranges operation.\n   * @returns Response data for the Page Blob Get Ranges operation.\n   */\n\n\n  getPageRanges(offset = 0, count, options = {}) {\n    var _this44 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-getPageRanges\", options);\n\n      try {\n        return yield _this44.pageBlobContext.getPageRanges(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          range: rangeToString({\n            offset,\n            count\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * getPageRangesSegment returns a single segment of page ranges starting from the\n   * specified Marker. Use an empty Marker to start enumeration from the beginning.\n   * After getting a segment, process it, and then call getPageRangesSegment again\n   * (passing the the previously-returned Marker) to get the next segment.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n   * @param options - Options to PageBlob Get Page Ranges Segment operation.\n   */\n\n\n  listPageRangesSegment(offset = 0, count, marker, options = {}) {\n    var _this45 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-getPageRangesSegment\", options);\n\n      try {\n        return yield _this45.pageBlobContext.getPageRanges(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          range: rangeToString({\n            offset,\n            count\n          }),\n          marker: marker,\n          maxPageSize: options.maxPageSize\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesResponseModel}\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param marker - A string value that identifies the portion of\n   *                          the get of page ranges to be returned with the next getting operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          getting operation did not return all page ranges remaining within the current page.\n   *                          The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of get\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to List Page Ranges operation.\n   */\n\n\n  listPageRangeItemSegments(offset = 0, count, marker, options = {}) {\n    return __asyncGenerator(this, arguments, function* listPageRangeItemSegments_1() {\n      let getPageRangeItemSegmentsResponse;\n\n      if (!!marker || marker === undefined) {\n        do {\n          getPageRangeItemSegmentsResponse = yield __await(this.listPageRangesSegment(offset, count, marker, options));\n          marker = getPageRangeItemSegmentsResponse.continuationToken;\n          yield yield __await(yield __await(getPageRangeItemSegmentsResponse));\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param options - Options to List Page Ranges operation.\n   */\n\n\n  listPageRangeItems(offset = 0, count, options = {}) {\n    return __asyncGenerator(this, arguments, function* listPageRangeItems_1() {\n      var e_1, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.listPageRangeItemSegments(offset, count, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const getPageRangesSegment = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to list of page ranges for a page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   *  .byPage() returns an async iterable iterator to list of page ranges for a page blob.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * // Get the pageBlobClient before you run these snippets,\n   * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\").getPageBlobClient(\"<your-blob-name>\");`\n   * let i = 1;\n   * for await (const pageRange of pageBlobClient.listPageRanges()) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = pageBlobClient.listPageRanges();\n   * let pageRangeItem = await iter.next();\n   * while (!pageRangeItem.done) {\n   *   console.log(`Page range ${i++}: ${pageRangeItem.value.start} - ${pageRangeItem.value.end}, IsClear: ${pageRangeItem.value.isClear}`);\n   *   pageRangeItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of pageBlobClient.listPageRanges().byPage({ maxPageSize: 20 })) {\n   *   for (const pageRange of response) {\n   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = pageBlobClient.listPageRanges().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 page ranges\n   * for (const pageRange of response) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   *\n   * iterator = pageBlobClient.listPageRanges().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 page ranges\n   * for (const blob of response) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   * ```\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param options - Options to the Page Blob Get Ranges operation.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n\n\n  listPageRanges(offset = 0, count, options = {}) {\n    options.conditions = options.conditions || {}; // AsyncIterableIterator to iterate over blobs\n\n    const iter = this.listPageRangeItems(offset, count, options);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.listPageRangeItemSegments(offset, count, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, options));\n      }\n    };\n  }\n  /**\n   * Gets the collection of page ranges that differ between a specified snapshot and this page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page blob\n   * @param count - Number of bytes to get ranges diff.\n   * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   * @returns Response data for the Page Blob Get Page Range Diff operation.\n   */\n\n\n  getPageRangesDiff(offset, count, prevSnapshot, options = {}) {\n    var _this46 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-getPageRangesDiff\", options);\n\n      try {\n        return yield _this46.pageBlobContext.getPageRangesDiff(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          prevsnapshot: prevSnapshot,\n          range: rangeToString({\n            offset,\n            count\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * getPageRangesDiffSegment returns a single segment of page ranges starting from the\n   * specified Marker for difference between previous snapshot and the target page blob.\n   * Use an empty Marker to start enumeration from the beginning.\n   * After getting a segment, process it, and then call getPageRangesDiffSegment again\n   * (passing the the previously-returned Marker) to get the next segment.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n   * @param marker - A string value that identifies the portion of the get to be returned with the next get operation.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   */\n\n\n  listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options) {\n    var _this47 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-getPageRangesDiffSegment\", options);\n\n      try {\n        return yield _this47.pageBlobContext.getPageRangesDiff(Object.assign({\n          abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,\n          leaseAccessConditions: options === null || options === void 0 ? void 0 : options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.conditions), {\n            ifTags: (_a = options === null || options === void 0 ? void 0 : options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          prevsnapshot: prevSnapshotOrUrl,\n          range: rangeToString({\n            offset: offset,\n            count: count\n          }),\n          marker: marker,\n          maxPageSize: options === null || options === void 0 ? void 0 : options.maxPageSize\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesDiffResponseModel}\n   *\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n   * @param marker - A string value that identifies the portion of\n   *                          the get of page ranges to be returned with the next getting operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          getting operation did not return all page ranges remaining within the current page.\n   *                          The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of get\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   */\n\n\n  listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options) {\n    return __asyncGenerator(this, arguments, function* listPageRangeDiffItemSegments_1() {\n      let getPageRangeItemSegmentsResponse;\n\n      if (!!marker || marker === undefined) {\n        do {\n          getPageRangeItemSegmentsResponse = yield __await(this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options));\n          marker = getPageRangeItemSegmentsResponse.continuationToken;\n          yield yield __await(yield __await(getPageRangeItemSegmentsResponse));\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   */\n\n\n  listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options) {\n    return __asyncGenerator(this, arguments, function* listPageRangeDiffItems_1() {\n      var e_2, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const getPageRangesSegment = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   *  .byPage() returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * // Get the pageBlobClient before you run these snippets,\n   * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\").getPageBlobClient(\"<your-blob-name>\");`\n   * let i = 1;\n   * for await (const pageRange of pageBlobClient.listPageRangesDiff()) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = pageBlobClient.listPageRangesDiff();\n   * let pageRangeItem = await iter.next();\n   * while (!pageRangeItem.done) {\n   *   console.log(`Page range ${i++}: ${pageRangeItem.value.start} - ${pageRangeItem.value.end}, IsClear: ${pageRangeItem.value.isClear}`);\n   *   pageRangeItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of pageBlobClient.listPageRangesDiff().byPage({ maxPageSize: 20 })) {\n   *   for (const pageRange of response) {\n   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = pageBlobClient.listPageRangesDiff().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 page ranges\n   * for (const pageRange of response) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   *\n   * iterator = pageBlobClient.listPageRangesDiff().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 page ranges\n   * for (const blob of response) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   * ```\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.\n   * @param options - Options to the Page Blob Get Ranges operation.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n\n\n  listPageRangesDiff(offset, count, prevSnapshot, options = {}) {\n    options.conditions = options.conditions || {}; // AsyncIterableIterator to iterate over blobs\n\n    const iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, Object.assign({}, options));\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, options));\n      }\n    };\n  }\n  /**\n   * Gets the collection of page ranges that differ between a specified snapshot and this page blob for managed disks.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page blob\n   * @param count - Number of bytes to get ranges diff.\n   * @param prevSnapshotUrl - URL of snapshot to retrieve the difference.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   * @returns Response data for the Page Blob Get Page Range Diff operation.\n   */\n\n\n  getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl, options = {}) {\n    var _this48 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-GetPageRangesDiffForManagedDisks\", options);\n\n      try {\n        return yield _this48.pageBlobContext.getPageRangesDiff(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          prevSnapshotUrl,\n          range: rangeToString({\n            offset,\n            count\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Resizes the page blob to the specified size (which must be a multiple of 512).\n   * @see https://docs.microsoft.com/rest/api/storageservices/set-blob-properties\n   *\n   * @param size - Target size\n   * @param options - Options to the Page Blob Resize operation.\n   * @returns Response data for the Page Blob Resize operation.\n   */\n\n\n  resize(size, options = {}) {\n    var _this49 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-resize\", options);\n\n      try {\n        return yield _this49.pageBlobContext.resize(size, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets a page blob's sequence number.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n   *\n   * @param sequenceNumberAction - Indicates how the service should modify the blob's sequence number.\n   * @param sequenceNumber - Required if sequenceNumberAction is max or update\n   * @param options - Options to the Page Blob Update Sequence Number operation.\n   * @returns Response data for the Page Blob Update Sequence Number operation.\n   */\n\n\n  updateSequenceNumber(sequenceNumberAction, sequenceNumber, options = {}) {\n    var _this50 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-updateSequenceNumber\", options);\n\n      try {\n        return yield _this50.pageBlobContext.updateSequenceNumber(sequenceNumberAction, Object.assign({\n          abortSignal: options.abortSignal,\n          blobSequenceNumber: sequenceNumber,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.\n   * The snapshot is copied such that only the differential changes between the previously\n   * copied snapshot are transferred to the destination.\n   * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.\n   * @see https://docs.microsoft.com/rest/api/storageservices/incremental-copy-blob\n   * @see https://docs.microsoft.com/en-us/azure/virtual-machines/windows/incremental-snapshots\n   *\n   * @param copySource - Specifies the name of the source page blob snapshot. For example,\n   *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n   * @param options - Options to the Page Blob Copy Incremental operation.\n   * @returns Response data for the Page Blob Copy Incremental operation.\n   */\n\n\n  startCopyIncremental(copySource, options = {}) {\n    var _this51 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-startCopyIncremental\", options);\n\n      try {\n        return yield _this51.pageBlobContext.copyIncremental(copySource, Object.assign({\n          abortSignal: options.abortSignal,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n} //# sourceMappingURL=Clients.js.map","map":{"version":3,"sources":["C:/Users/Equipo/source/Tgsc-Proyectos/youManager-web/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/Clients.js"],"names":["__asyncDelegator","__asyncGenerator","__asyncValues","__await","generateUuid","getDefaultProxySettings","isNode","isTokenCredential","URLBuilder","SpanStatusCode","BlobDownloadResponse","BlobQueryResponse","AnonymousCredential","StorageSharedKeyCredential","AppendBlob","Blob","StorageBlob","BlockBlob","PageBlob","ensureCpkIfSpecified","toAccessTier","rangeResponseFromModel","newPipeline","isPipelineLike","BlobBeginCopyFromUrlPoller","rangeToString","StorageClient","Batch","BufferScheduler","BlobDoesNotUseCustomerSpecifiedEncryption","BlobUsesCustomerSpecifiedEncryptionMsg","BLOCK_BLOB_MAX_BLOCKS","BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES","BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES","DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES","DEFAULT_BLOCK_BUFFER_SIZE_BYTES","DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS","ETagAny","URLConstants","createSpan","convertTracingToRequestOptionsBase","appendToURLPath","appendToURLQuery","extractConnectionStringParts","ExtractPageRangeInfoItems","generateBlockID","getURLParameter","httpAuthorizationToString","isIpEndpointStyle","parseObjectReplicationRecord","setURLParameter","toBlobTags","toBlobTagsString","toQuerySerialization","toTags","fsCreateReadStream","fsStat","readStreamToLocalFile","streamToBuffer","generateBlobSASQueryParameters","BlobLeaseClient","BlobClient","constructor","urlOrConnectionString","credentialOrPipelineOrContainerName","blobNameOrOptions","options","pipeline","url","containerName","blobName","extractedCreds","kind","sharedKeyCredential","accountName","accountKey","encodeURIComponent","proxyOptions","proxyUri","Error","accountSas","_name","_containerName","getBlobAndContainerNamesFromUrl","blobContext","storageClientContext","_snapshot","Parameters","SNAPSHOT","_versionId","VERSIONID","name","withSnapshot","snapshot","length","undefined","withVersion","versionId","getAppendBlobClient","AppendBlobClient","getBlockBlobClient","BlockBlobClient","getPageBlobClient","PageBlobClient","download","offset","count","_a","conditions","customerProvidedKey","isHttps","span","updatedOptions","res","Object","assign","abortSignal","leaseAccessConditions","modifiedAccessConditions","ifTags","tagConditions","requestOptions","onDownloadProgress","onProgress","range","rangeGetContentMD5","rangeGetContentCRC64","rangeGetContentCrc64","cpkInfo","wrappedRes","_response","objectReplicationDestinationPolicyId","objectReplicationPolicyId","objectReplicationSourceProperties","objectReplicationRules","maxRetryRequests","contentLength","RangeError","etag","start","updatedDownloadOptions","ifMatch","ifModifiedSince","ifNoneMatch","ifUnmodifiedSince","readableStreamBody","e","setStatus","code","ERROR","message","end","exists","getProperties","tracingOptions","statusCode","details","errorCode","delete","deleteSnapshots","deleteIfExists","_b","succeeded","response","parsedHeaders","undelete","setHTTPHeaders","blobHTTPHeaders","setHttpHeaders","blobHttpHeaders","setMetadata","metadata","encryptionScope","setTags","tags","getTags","wrappedResponse","blobTagSet","getBlobLeaseClient","proposeLeaseId","createSnapshot","beginCopyFromURL","copySource","client","abortCopyFromURL","args","startCopyFromURL","poller","blobClient","intervalInMs","resumeFrom","startCopyFromURLOptions","poll","copyId","syncCopyFromURL","_c","sourceConditions","copyFromURL","sourceModifiedAccessConditions","sourceIfMatch","sourceIfModifiedSince","sourceIfNoneMatch","sourceIfUnmodifiedSince","sourceContentMD5","copySourceAuthorization","sourceAuthorization","blobTagsString","immutabilityPolicyExpiry","immutabilityPolicy","expiriesOn","immutabilityPolicyMode","policyMode","legalHold","copySourceTags","setAccessTier","tier","setTier","rehydratePriority","downloadToBuffer","param1","param2","param3","param4","buffer","Buffer","blockSize","alloc","error","transferProgress","batch","concurrency","off","addOperation","chunkEnd","maxRetryRequestsPerBlock","stream","loadedBytes","do","downloadToFile","filePath","blobDownloadStream","parsedUrl","parse","getHost","split","pathComponents","getPath","match","decodeURIComponent","replace","sourceIfTags","sealBlob","generateSasUrl","Promise","resolve","credential","sas","snapshotTime","toString","deleteImmutabilityPolicy","setImmutabilityPolicy","modifiedAccessCondition","setLegalHold","legalHoldEnabled","appendBlobContext","create","createIfNotExists","seal","appendPositionAccessConditions","appendBlock","body","onUploadProgress","transactionalContentMD5","transactionalContentCrc64","appendBlockFromURL","sourceURL","sourceOffset","appendBlockFromUrl","sourceRange","sourceContentCrc64","blockBlobContext","_blobContext","query","queryRequest","queryType","expression","inputSerialization","inputTextConfiguration","outputSerialization","outputTextConfiguration","onError","upload","syncUploadFromURL","_d","_e","putBlobFromUrl","stageBlock","blockId","stageBlockFromURL","commitBlockList","blocks","latest","getBlockList","listType","committedBlocks","uncommittedBlocks","uploadData","data","ArrayBuffer","from","byteOffset","byteLength","uploadSeekableInternal","size","slice","browserBlob","uploadBrowserData","browserData","bodyFactory","maxSingleShotSize","Math","ceil","numBlocks","floor","blockList","blockIDPrefix","i","blockID","push","uploadFile","autoClose","Infinity","uploadStream","bufferSize","maxConcurrency","blockNum","scheduler","pageBlobContext","blobSequenceNumber","uploadPages","sequenceNumberAccessConditions","uploadPagesFromURL","destOffset","clearPages","getPageRanges","then","listPageRangesSegment","marker","maxPageSize","listPageRangeItemSegments","arguments","listPageRangeItemSegments_1","getPageRangeItemSegmentsResponse","continuationToken","listPageRangeItems","listPageRangeItems_1","e_1","next","done","getPageRangesSegment","value","e_1_1","return","call","listPageRanges","iter","Symbol","asyncIterator","byPage","settings","getPageRangesDiff","prevSnapshot","prevsnapshot","listPageRangesDiffSegment","prevSnapshotOrUrl","listPageRangeDiffItemSegments","listPageRangeDiffItemSegments_1","listPageRangeDiffItems","listPageRangeDiffItems_1","e_2","e_2_1","listPageRangesDiff","getPageRangesDiffForManagedDisks","prevSnapshotUrl","resize","updateSequenceNumber","sequenceNumberAction","sequenceNumber","startCopyIncremental","copyIncremental"],"mappings":"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","sourcesContent":["import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { generateUuid, getDefaultProxySettings, isNode, isTokenCredential, URLBuilder, } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { BlobDownloadResponse } from \"./BlobDownloadResponse\";\nimport { BlobQueryResponse } from \"./BlobQueryResponse\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AppendBlob, Blob as StorageBlob, BlockBlob, PageBlob } from \"./generated/src/operations\";\nimport { ensureCpkIfSpecified, toAccessTier, } from \"./models\";\nimport { rangeResponseFromModel, } from \"./PageBlobRangeResponse\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { BlobBeginCopyFromUrlPoller, } from \"./pollers/BlobStartCopyFromUrlPoller\";\nimport { rangeToString } from \"./Range\";\nimport { StorageClient } from \"./StorageClient\";\nimport { Batch } from \"./utils/Batch\";\nimport { BufferScheduler } from \"../../storage-common/src\";\nimport { BlobDoesNotUseCustomerSpecifiedEncryption, BlobUsesCustomerSpecifiedEncryptionMsg, BLOCK_BLOB_MAX_BLOCKS, BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES, BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES, DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES, DEFAULT_BLOCK_BUFFER_SIZE_BYTES, DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS, ETagAny, URLConstants, } from \"./utils/constants\";\nimport { createSpan, convertTracingToRequestOptionsBase } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, ExtractPageRangeInfoItems, generateBlockID, getURLParameter, httpAuthorizationToString, isIpEndpointStyle, parseObjectReplicationRecord, setURLParameter, toBlobTags, toBlobTagsString, toQuerySerialization, toTags, } from \"./utils/utils.common\";\nimport { fsCreateReadStream, fsStat, readStreamToLocalFile, streamToBuffer, } from \"./utils/utils.node\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\n/**\n * A BlobClient represents a URL to an Azure Storage blob; the blob may be a block blob,\n * append blob, or page blob.\n */\nexport class BlobClient extends StorageClient {\n    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        options = options || {};\n        let pipeline;\n        let url;\n        if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n            // (url: string, pipeline: Pipeline)\n            url = urlOrConnectionString;\n            pipeline = credentialOrPipelineOrContainerName;\n        }\n        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n            isTokenCredential(credentialOrPipelineOrContainerName)) {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            url = urlOrConnectionString;\n            options = blobNameOrOptions;\n            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n        }\n        else if (!credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName !== \"string\") {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            // The second parameter is undefined. Use anonymous credential.\n            url = urlOrConnectionString;\n            pipeline = newPipeline(new AnonymousCredential(), options);\n        }\n        else if (credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName === \"string\" &&\n            blobNameOrOptions &&\n            typeof blobNameOrOptions === \"string\") {\n            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n            const containerName = credentialOrPipelineOrContainerName;\n            const blobName = blobNameOrOptions;\n            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n            if (extractedCreds.kind === \"AccountConnString\") {\n                if (isNode) {\n                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n                    if (!options.proxyOptions) {\n                        options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n                    }\n                    pipeline = newPipeline(sharedKeyCredential, options);\n                }\n                else {\n                    throw new Error(\"Account connection string is only supported in Node.js environment\");\n                }\n            }\n            else if (extractedCreds.kind === \"SASConnString\") {\n                url =\n                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +\n                        \"?\" +\n                        extractedCreds.accountSas;\n                pipeline = newPipeline(new AnonymousCredential(), options);\n            }\n            else {\n                throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n            }\n        }\n        else {\n            throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n        }\n        super(url, pipeline);\n        ({ blobName: this._name, containerName: this._containerName } =\n            this.getBlobAndContainerNamesFromUrl());\n        this.blobContext = new StorageBlob(this.storageClientContext);\n        this._snapshot = getURLParameter(this.url, URLConstants.Parameters.SNAPSHOT);\n        this._versionId = getURLParameter(this.url, URLConstants.Parameters.VERSIONID);\n    }\n    /**\n     * The name of the blob.\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * The name of the storage container the blob is associated with.\n     */\n    get containerName() {\n        return this._containerName;\n    }\n    /**\n     * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.\n     * Provide \"\" will remove the snapshot and return a Client to the base blob.\n     *\n     * @param snapshot - The snapshot timestamp.\n     * @returns A new BlobClient object identical to the source but with the specified snapshot timestamp\n     */\n    withSnapshot(snapshot) {\n        return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * Creates a new BlobClient object pointing to a version of this blob.\n     * Provide \"\" will remove the versionId and return a Client to the base blob.\n     *\n     * @param versionId - The versionId.\n     * @returns A new BlobClient object pointing to the version of this blob.\n     */\n    withVersion(versionId) {\n        return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.VERSIONID, versionId.length === 0 ? undefined : versionId), this.pipeline);\n    }\n    /**\n     * Creates a AppendBlobClient object.\n     *\n     */\n    getAppendBlobClient() {\n        return new AppendBlobClient(this.url, this.pipeline);\n    }\n    /**\n     * Creates a BlockBlobClient object.\n     *\n     */\n    getBlockBlobClient() {\n        return new BlockBlobClient(this.url, this.pipeline);\n    }\n    /**\n     * Creates a PageBlobClient object.\n     *\n     */\n    getPageBlobClient() {\n        return new PageBlobClient(this.url, this.pipeline);\n    }\n    /**\n     * Reads or downloads a blob from the system, including its metadata and properties.\n     * You can also call Get Blob to read a snapshot.\n     *\n     * * In Node.js, data returns in a Readable stream readableStreamBody\n     * * In browsers, data returns in a promise blobBody\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob\n     *\n     * @param offset - From which position of the blob to download, greater than or equal to 0\n     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n     * @param options - Optional options to Blob Download operation.\n     *\n     *\n     * Example usage (Node.js):\n     *\n     * ```js\n     * // Download and convert a blob to a string\n     * const downloadBlockBlobResponse = await blobClient.download();\n     * const downloaded = await streamToBuffer(downloadBlockBlobResponse.readableStreamBody);\n     * console.log(\"Downloaded blob content:\", downloaded.toString());\n     *\n     * async function streamToBuffer(readableStream) {\n     * return new Promise((resolve, reject) => {\n     * const chunks = [];\n     * readableStream.on(\"data\", (data) => {\n     * chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n     * });\n     * readableStream.on(\"end\", () => {\n     * resolve(Buffer.concat(chunks));\n     * });\n     * readableStream.on(\"error\", reject);\n     * });\n     * }\n     * ```\n     *\n     * Example usage (browser):\n     *\n     * ```js\n     * // Download and convert a blob to a string\n     * const downloadBlockBlobResponse = await blobClient.download();\n     * const downloaded = await blobToString(await downloadBlockBlobResponse.blobBody);\n     * console.log(\n     *   \"Downloaded blob content\",\n     *   downloaded\n     * );\n     *\n     * async function blobToString(blob: Blob): Promise<string> {\n     *   const fileReader = new FileReader();\n     *   return new Promise<string>((resolve, reject) => {\n     *     fileReader.onloadend = (ev: any) => {\n     *       resolve(ev.target!.result);\n     *     };\n     *     fileReader.onerror = reject;\n     *     fileReader.readAsText(blob);\n     *   });\n     * }\n     * ```\n     */\n    async download(offset = 0, count, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        options.conditions = options.conditions || {};\n        ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n        const { span, updatedOptions } = createSpan(\"BlobClient-download\", options);\n        try {\n            const res = await this.blobContext.download(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), requestOptions: {\n                    onDownloadProgress: isNode ? undefined : options.onProgress, // for Node.js, progress is reported by RetriableReadableStream\n                }, range: offset === 0 && !count ? undefined : rangeToString({ offset, count }), rangeGetContentMD5: options.rangeGetContentMD5, rangeGetContentCRC64: options.rangeGetContentCrc64, snapshot: options.snapshot, cpkInfo: options.customerProvidedKey }, convertTracingToRequestOptionsBase(updatedOptions)));\n            const wrappedRes = Object.assign(Object.assign({}, res), { _response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules) });\n            // Return browser response immediately\n            if (!isNode) {\n                return wrappedRes;\n            }\n            // We support retrying when download stream unexpected ends in Node.js runtime\n            // Following code shouldn't be bundled into browser build, however some\n            // bundlers may try to bundle following code and \"FileReadResponse.ts\".\n            // In this case, \"FileDownloadResponse.browser.ts\" will be used as a shim of \"FileDownloadResponse.ts\"\n            // The config is in package.json \"browser\" field\n            if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {\n                // TODO: Default value or make it a required parameter?\n                options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;\n            }\n            if (res.contentLength === undefined) {\n                throw new RangeError(`File download response doesn't contain valid content length header`);\n            }\n            if (!res.etag) {\n                throw new RangeError(`File download response doesn't contain valid etag header`);\n            }\n            return new BlobDownloadResponse(wrappedRes, async (start) => {\n                var _a;\n                const updatedDownloadOptions = {\n                    leaseAccessConditions: options.conditions,\n                    modifiedAccessConditions: {\n                        ifMatch: options.conditions.ifMatch || res.etag,\n                        ifModifiedSince: options.conditions.ifModifiedSince,\n                        ifNoneMatch: options.conditions.ifNoneMatch,\n                        ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,\n                        ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions,\n                    },\n                    range: rangeToString({\n                        count: offset + res.contentLength - start,\n                        offset: start,\n                    }),\n                    rangeGetContentMD5: options.rangeGetContentMD5,\n                    rangeGetContentCRC64: options.rangeGetContentCrc64,\n                    snapshot: options.snapshot,\n                    cpkInfo: options.customerProvidedKey,\n                };\n                // Debug purpose only\n                // console.log(\n                //   `Read from internal stream, range: ${\n                //     updatedOptions.range\n                //   }, options: ${JSON.stringify(updatedOptions)}`\n                // );\n                return (await this.blobContext.download(Object.assign({ abortSignal: options.abortSignal }, updatedDownloadOptions))).readableStreamBody;\n            }, offset, res.contentLength, {\n                maxRetryRequests: options.maxRetryRequests,\n                onProgress: options.onProgress,\n            });\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns true if the Azure blob resource represented by this client exists; false otherwise.\n     *\n     * NOTE: use this function with care since an existing blob might be deleted by other clients or\n     * applications. Vice versa new blobs might be added by other clients or applications after this\n     * function completes.\n     *\n     * @param options - options to Exists operation.\n     */\n    async exists(options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-exists\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            await this.getProperties({\n                abortSignal: options.abortSignal,\n                customerProvidedKey: options.customerProvidedKey,\n                conditions: options.conditions,\n                tracingOptions: updatedOptions.tracingOptions,\n            });\n            return true;\n        }\n        catch (e) {\n            if (e.statusCode === 404) {\n                // Expected exception when checking blob existence\n                return false;\n            }\n            else if (e.statusCode === 409 &&\n                (e.details.errorCode === BlobUsesCustomerSpecifiedEncryptionMsg ||\n                    e.details.errorCode === BlobDoesNotUseCustomerSpecifiedEncryption)) {\n                // Expected exception when checking blob existence\n                return true;\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns all user-defined metadata, standard HTTP properties, and system properties\n     * for the blob. It does not return the content of the blob.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties\n     *\n     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n     * they originally contained uppercase characters. This differs from the metadata keys returned by\n     * the methods of {@link ContainerClient} that list blobs using the `includeMetadata` option, which\n     * will retain their original casing.\n     *\n     * @param options - Optional options to Get Properties operation.\n     */\n    async getProperties(options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-getProperties\", options);\n        try {\n            options.conditions = options.conditions || {};\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            const res = await this.blobContext.getProperties(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey }, convertTracingToRequestOptionsBase(updatedOptions)));\n            return Object.assign(Object.assign({}, res), { _response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules) });\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Marks the specified blob or snapshot for deletion. The blob is later deleted\n     * during garbage collection. Note that in order to delete a blob, you must delete\n     * all of its snapshots. You can delete both at the same time with the Delete\n     * Blob operation.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n     *\n     * @param options - Optional options to Blob Delete operation.\n     */\n    async delete(options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-delete\", options);\n        options.conditions = options.conditions || {};\n        try {\n            return await this.blobContext.delete(Object.assign({ abortSignal: options.abortSignal, deleteSnapshots: options.deleteSnapshots, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Marks the specified blob or snapshot for deletion if it exists. The blob is later deleted\n     * during garbage collection. Note that in order to delete a blob, you must delete\n     * all of its snapshots. You can delete both at the same time with the Delete\n     * Blob operation.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n     *\n     * @param options - Optional options to Blob Delete operation.\n     */\n    async deleteIfExists(options = {}) {\n        var _a, _b;\n        const { span, updatedOptions } = createSpan(\"BlobClient-deleteIfExists\", options);\n        try {\n            const res = await this.delete(updatedOptions);\n            return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });\n        }\n        catch (e) {\n            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobNotFound\") {\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: \"Expected exception when deleting a blob or snapshot only if it exists.\",\n                });\n                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Restores the contents and metadata of soft deleted blob and any associated\n     * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29\n     * or later.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/undelete-blob\n     *\n     * @param options - Optional options to Blob Undelete operation.\n     */\n    async undelete(options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-undelete\", options);\n        try {\n            return await this.blobContext.undelete(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets system properties on the blob.\n     *\n     * If no value provided, or no value provided for the specified blob HTTP headers,\n     * these blob HTTP headers without a value will be cleared.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n     *\n     * @param blobHTTPHeaders - If no value provided, or no value provided for\n     *                                                   the specified blob HTTP headers, these blob HTTP\n     *                                                   headers without a value will be cleared.\n     *                                                   A common header to set is `blobContentType`\n     *                                                   enabling the browser to provide functionality\n     *                                                   based on file type.\n     * @param options - Optional options to Blob Set HTTP Headers operation.\n     */\n    async setHTTPHeaders(blobHTTPHeaders, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-setHTTPHeaders\", options);\n        options.conditions = options.conditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blobContext.setHttpHeaders(Object.assign({ abortSignal: options.abortSignal, blobHttpHeaders: blobHTTPHeaders, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets user-defined metadata for the specified blob as one or more name-value pairs.\n     *\n     * If no option provided, or no metadata defined in the parameter, the blob\n     * metadata will be removed.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata\n     *\n     * @param metadata - Replace existing metadata with this value.\n     *                               If no value provided the existing metadata will be removed.\n     * @param options - Optional options to Set Metadata operation.\n     */\n    async setMetadata(metadata, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-setMetadata\", options);\n        options.conditions = options.conditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blobContext.setMetadata(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets tags on the underlying blob.\n     * A blob can have up to 10 tags. Tag keys must be between 1 and 128 characters.  Tag values must be between 0 and 256 characters.\n     * Valid tag key and value characters include lower and upper case letters, digits (0-9),\n     * space (' '), plus ('+'), minus ('-'), period ('.'), foward slash ('/'), colon (':'), equals ('='), and underscore ('_').\n     *\n     * @param tags -\n     * @param options -\n     */\n    async setTags(tags, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-setTags\", options);\n        try {\n            return await this.blobContext.setTags(Object.assign(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)), { tags: toBlobTags(tags) }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Gets the tags associated with the underlying blob.\n     *\n     * @param options -\n     */\n    async getTags(options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-getTags\", options);\n        try {\n            const response = await this.blobContext.getTags(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n            const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, tags: toTags({ blobTagSet: response.blobTagSet }) || {} });\n            return wrappedResponse;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Get a {@link BlobLeaseClient} that manages leases on the blob.\n     *\n     * @param proposeLeaseId - Initial proposed lease Id.\n     * @returns A new BlobLeaseClient object for managing leases on the blob.\n     */\n    getBlobLeaseClient(proposeLeaseId) {\n        return new BlobLeaseClient(this, proposeLeaseId);\n    }\n    /**\n     * Creates a read-only snapshot of a blob.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/snapshot-blob\n     *\n     * @param options - Optional options to the Blob Create Snapshot operation.\n     */\n    async createSnapshot(options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-createSnapshot\", options);\n        options.conditions = options.conditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blobContext.createSnapshot(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Asynchronously copies a blob to a destination within the storage account.\n     * This method returns a long running operation poller that allows you to wait\n     * indefinitely until the copy is completed.\n     * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.\n     * Note that the onProgress callback will not be invoked if the operation completes in the first\n     * request, and attempting to cancel a completed copy will result in an error being thrown.\n     *\n     * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n     * a committed blob in any Azure storage account.\n     * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n     * an Azure file in any Azure storage account.\n     * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n     * operation to copy from another storage account.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n     *\n     * Example using automatic polling:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url');\n     * const result = await copyPoller.pollUntilDone();\n     * ```\n     *\n     * Example using manual polling:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url');\n     * while (!poller.isDone()) {\n     *    await poller.poll();\n     * }\n     * const result = copyPoller.getResult();\n     * ```\n     *\n     * Example using progress updates:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url', {\n     *   onProgress(state) {\n     *     console.log(`Progress: ${state.copyProgress}`);\n     *   }\n     * });\n     * const result = await copyPoller.pollUntilDone();\n     * ```\n     *\n     * Example using a changing polling interval (default 15 seconds):\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url', {\n     *   intervalInMs: 1000 // poll blob every 1 second for copy progress\n     * });\n     * const result = await copyPoller.pollUntilDone();\n     * ```\n     *\n     * Example using copy cancellation:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url');\n     * // cancel operation after starting it.\n     * try {\n     *   await copyPoller.cancelOperation();\n     *   // calls to get the result now throw PollerCancelledError\n     *   await copyPoller.getResult();\n     * } catch (err) {\n     *   if (err.name === 'PollerCancelledError') {\n     *     console.log('The copy was cancelled.');\n     *   }\n     * }\n     * ```\n     *\n     * @param copySource - url to the source Azure Blob/File.\n     * @param options - Optional options to the Blob Start Copy From URL operation.\n     */\n    async beginCopyFromURL(copySource, options = {}) {\n        const client = {\n            abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),\n            getProperties: (...args) => this.getProperties(...args),\n            startCopyFromURL: (...args) => this.startCopyFromURL(...args),\n        };\n        const poller = new BlobBeginCopyFromUrlPoller({\n            blobClient: client,\n            copySource,\n            intervalInMs: options.intervalInMs,\n            onProgress: options.onProgress,\n            resumeFrom: options.resumeFrom,\n            startCopyFromURLOptions: options,\n        });\n        // Trigger the startCopyFromURL call by calling poll.\n        // Any errors from this method should be surfaced to the user.\n        await poller.poll();\n        return poller;\n    }\n    /**\n     * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero\n     * length and full metadata. Version 2012-02-12 and newer.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-blob\n     *\n     * @param copyId - Id of the Copy From URL operation.\n     * @param options - Optional options to the Blob Abort Copy From URL operation.\n     */\n    async abortCopyFromURL(copyId, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-abortCopyFromURL\", options);\n        try {\n            return await this.blobContext.abortCopyFromURL(copyId, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not\n     * return a response until the copy is complete.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob-from-url\n     *\n     * @param copySource - The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication\n     * @param options -\n     */\n    async syncCopyFromURL(copySource, options = {}) {\n        var _a, _b, _c;\n        const { span, updatedOptions } = createSpan(\"BlobClient-syncCopyFromURL\", options);\n        options.conditions = options.conditions || {};\n        options.sourceConditions = options.sourceConditions || {};\n        try {\n            return await this.blobContext.copyFromURL(copySource, Object.assign({ abortSignal: options.abortSignal, metadata: options.metadata, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n                }, sourceContentMD5: options.sourceContentMD5, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization), blobTagsString: toBlobTagsString(options.tags), immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, encryptionScope: options.encryptionScope, copySourceTags: options.copySourceTags }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets the tier on a blob. The operation is allowed on a page blob in a premium\n     * storage account and on a block blob in a blob storage account (locally redundant\n     * storage only). A premium page blob's tier determines the allowed size, IOPS,\n     * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive\n     * storage type. This operation does not update the blob's ETag.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-tier\n     *\n     * @param tier - The tier to be set on the blob. Valid values are Hot, Cool, or Archive.\n     * @param options - Optional options to the Blob Set Tier operation.\n     */\n    async setAccessTier(tier, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-setAccessTier\", options);\n        try {\n            return await this.blobContext.setTier(toAccessTier(tier), Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), rehydratePriority: options.rehydratePriority }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    async downloadToBuffer(param1, param2, param3, param4 = {}) {\n        let buffer;\n        let offset = 0;\n        let count = 0;\n        let options = param4;\n        if (param1 instanceof Buffer) {\n            buffer = param1;\n            offset = param2 || 0;\n            count = typeof param3 === \"number\" ? param3 : 0;\n        }\n        else {\n            offset = typeof param1 === \"number\" ? param1 : 0;\n            count = typeof param2 === \"number\" ? param2 : 0;\n            options = param3 || {};\n        }\n        const { span, updatedOptions } = createSpan(\"BlobClient-downloadToBuffer\", options);\n        try {\n            if (!options.blockSize) {\n                options.blockSize = 0;\n            }\n            if (options.blockSize < 0) {\n                throw new RangeError(\"blockSize option must be >= 0\");\n            }\n            if (options.blockSize === 0) {\n                options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n            }\n            if (offset < 0) {\n                throw new RangeError(\"offset option must be >= 0\");\n            }\n            if (count && count <= 0) {\n                throw new RangeError(\"count option must be greater than 0\");\n            }\n            if (!options.conditions) {\n                options.conditions = {};\n            }\n            // Customer doesn't specify length, get it\n            if (!count) {\n                const response = await this.getProperties(Object.assign(Object.assign({}, options), { tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions)) }));\n                count = response.contentLength - offset;\n                if (count < 0) {\n                    throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);\n                }\n            }\n            // Allocate the buffer of size = count if the buffer is not provided\n            if (!buffer) {\n                try {\n                    buffer = Buffer.alloc(count);\n                }\n                catch (error) {\n                    throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the \"downloadToBuffer\" method or try using other methods like \"download\" or \"downloadToFile\".\\t ${error.message}`);\n                }\n            }\n            if (buffer.length < count) {\n                throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);\n            }\n            let transferProgress = 0;\n            const batch = new Batch(options.concurrency);\n            for (let off = offset; off < offset + count; off = off + options.blockSize) {\n                batch.addOperation(async () => {\n                    // Exclusive chunk end position\n                    let chunkEnd = offset + count;\n                    if (off + options.blockSize < chunkEnd) {\n                        chunkEnd = off + options.blockSize;\n                    }\n                    const response = await this.download(off, chunkEnd - off, {\n                        abortSignal: options.abortSignal,\n                        conditions: options.conditions,\n                        maxRetryRequests: options.maxRetryRequestsPerBlock,\n                        customerProvidedKey: options.customerProvidedKey,\n                        tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions)),\n                    });\n                    const stream = response.readableStreamBody;\n                    await streamToBuffer(stream, buffer, off - offset, chunkEnd - offset);\n                    // Update progress after block is downloaded, in case of block trying\n                    // Could provide finer grained progress updating inside HTTP requests,\n                    // only if convenience layer download try is enabled\n                    transferProgress += chunkEnd - off;\n                    if (options.onProgress) {\n                        options.onProgress({ loadedBytes: transferProgress });\n                    }\n                });\n            }\n            await batch.do();\n            return buffer;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Downloads an Azure Blob to a local file.\n     * Fails if the the given file path already exits.\n     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.\n     *\n     * @param filePath -\n     * @param offset - From which position of the block blob to download.\n     * @param count - How much data to be downloaded. Will download to the end when passing undefined.\n     * @param options - Options to Blob download options.\n     * @returns The response data for blob download operation,\n     *                                                 but with readableStreamBody set to undefined since its\n     *                                                 content is already read and written into a local file\n     *                                                 at the specified path.\n     */\n    async downloadToFile(filePath, offset = 0, count, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-downloadToFile\", options);\n        try {\n            const response = await this.download(offset, count, Object.assign(Object.assign({}, options), { tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions)) }));\n            if (response.readableStreamBody) {\n                await readStreamToLocalFile(response.readableStreamBody, filePath);\n            }\n            // The stream is no longer accessible so setting it to undefined.\n            response.blobDownloadStream = undefined;\n            return response;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    getBlobAndContainerNamesFromUrl() {\n        let containerName;\n        let blobName;\n        try {\n            //  URL may look like the following\n            // \"https://myaccount.blob.core.windows.net/mycontainer/blob?sasString\";\n            // \"https://myaccount.blob.core.windows.net/mycontainer/blob\";\n            // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt?sasString\";\n            // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt\";\n            // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername/blob`\n            // http://localhost:10001/devstoreaccount1/containername/blob\n            const parsedUrl = URLBuilder.parse(this.url);\n            if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n                // \"https://myaccount.blob.core.windows.net/containername/blob\".\n                // .getPath() -> /containername/blob\n                const pathComponents = parsedUrl.getPath().match(\"/([^/]*)(/(.*))?\");\n                containerName = pathComponents[1];\n                blobName = pathComponents[3];\n            }\n            else if (isIpEndpointStyle(parsedUrl)) {\n                // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername/blob\n                // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername/blob\n                // .getPath() -> /devstoreaccount1/containername/blob\n                const pathComponents = parsedUrl.getPath().match(\"/([^/]*)/([^/]*)(/(.*))?\");\n                containerName = pathComponents[2];\n                blobName = pathComponents[4];\n            }\n            else {\n                // \"https://customdomain.com/containername/blob\".\n                // .getPath() -> /containername/blob\n                const pathComponents = parsedUrl.getPath().match(\"/([^/]*)(/(.*))?\");\n                containerName = pathComponents[1];\n                blobName = pathComponents[3];\n            }\n            // decode the encoded blobName, containerName - to get all the special characters that might be present in them\n            containerName = decodeURIComponent(containerName);\n            blobName = decodeURIComponent(blobName);\n            // Azure Storage Server will replace \"\\\" with \"/\" in the blob names\n            //   doing the same in the SDK side so that the user doesn't have to replace \"\\\" instances in the blobName\n            blobName = blobName.replace(/\\\\/g, \"/\");\n            if (!containerName) {\n                throw new Error(\"Provided containerName is invalid.\");\n            }\n            return { blobName, containerName };\n        }\n        catch (error) {\n            throw new Error(\"Unable to extract blobName and containerName with provided information.\");\n        }\n    }\n    /**\n     * Asynchronously copies a blob to a destination within the storage account.\n     * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n     * a committed blob in any Azure storage account.\n     * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n     * an Azure file in any Azure storage account.\n     * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n     * operation to copy from another storage account.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n     *\n     * @param copySource - url to the source Azure Blob/File.\n     * @param options - Optional options to the Blob Start Copy From URL operation.\n     */\n    async startCopyFromURL(copySource, options = {}) {\n        var _a, _b, _c;\n        const { span, updatedOptions } = createSpan(\"BlobClient-startCopyFromURL\", options);\n        options.conditions = options.conditions || {};\n        options.sourceConditions = options.sourceConditions || {};\n        try {\n            return await this.blobContext.startCopyFromURL(copySource, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n                    sourceIfTags: options.sourceConditions.tagConditions,\n                }, immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, rehydratePriority: options.rehydratePriority, tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags), sealBlob: options.sealBlob }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Only available for BlobClient constructed with a shared key credential.\n     *\n     * Generates a Blob Service Shared Access Signature (SAS) URI based on the client properties\n     * and parameters passed in. The SAS is signed by the shared key credential of the client.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n     *\n     * @param options - Optional parameters.\n     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n     */\n    generateSasUrl(options) {\n        return new Promise((resolve) => {\n            if (!(this.credential instanceof StorageSharedKeyCredential)) {\n                throw new RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n            }\n            const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options), this.credential).toString();\n            resolve(appendToURLQuery(this.url, sas));\n        });\n    }\n    /**\n     * Delete the immutablility policy on the blob.\n     *\n     * @param options - Optional options to delete immutability policy on the blob.\n     */\n    async deleteImmutabilityPolicy(options) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-deleteImmutabilityPolicy\", options);\n        try {\n            return await this.blobContext.deleteImmutabilityPolicy(Object.assign({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Set immutablility policy on the blob.\n     *\n     * @param options - Optional options to set immutability policy on the blob.\n     */\n    async setImmutabilityPolicy(immutabilityPolicy, options) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-setImmutabilityPolicy\", options);\n        try {\n            return await this.blobContext.setImmutabilityPolicy(Object.assign({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal, immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn, immutabilityPolicyMode: immutabilityPolicy.policyMode, modifiedAccessConditions: options === null || options === void 0 ? void 0 : options.modifiedAccessCondition }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Set legal hold on the blob.\n     *\n     * @param options - Optional options to set legal hold on the blob.\n     */\n    async setLegalHold(legalHoldEnabled, options) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-setLegalHold\", options);\n        try {\n            return await this.blobContext.setLegalHold(legalHoldEnabled, Object.assign({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n/**\n * AppendBlobClient defines a set of operations applicable to append blobs.\n */\nexport class AppendBlobClient extends BlobClient {\n    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n        //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n        let pipeline;\n        let url;\n        options = options || {};\n        if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n            // (url: string, pipeline: Pipeline)\n            url = urlOrConnectionString;\n            pipeline = credentialOrPipelineOrContainerName;\n        }\n        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n            isTokenCredential(credentialOrPipelineOrContainerName)) {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)      url = urlOrConnectionString;\n            url = urlOrConnectionString;\n            options = blobNameOrOptions;\n            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n        }\n        else if (!credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName !== \"string\") {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            url = urlOrConnectionString;\n            // The second parameter is undefined. Use anonymous credential.\n            pipeline = newPipeline(new AnonymousCredential(), options);\n        }\n        else if (credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName === \"string\" &&\n            blobNameOrOptions &&\n            typeof blobNameOrOptions === \"string\") {\n            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n            const containerName = credentialOrPipelineOrContainerName;\n            const blobName = blobNameOrOptions;\n            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n            if (extractedCreds.kind === \"AccountConnString\") {\n                if (isNode) {\n                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n                    if (!options.proxyOptions) {\n                        options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n                    }\n                    pipeline = newPipeline(sharedKeyCredential, options);\n                }\n                else {\n                    throw new Error(\"Account connection string is only supported in Node.js environment\");\n                }\n            }\n            else if (extractedCreds.kind === \"SASConnString\") {\n                url =\n                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +\n                        \"?\" +\n                        extractedCreds.accountSas;\n                pipeline = newPipeline(new AnonymousCredential(), options);\n            }\n            else {\n                throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n            }\n        }\n        else {\n            throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n        }\n        super(url, pipeline);\n        this.appendBlobContext = new AppendBlob(this.storageClientContext);\n    }\n    /**\n     * Creates a new AppendBlobClient object identical to the source but with the\n     * specified snapshot timestamp.\n     * Provide \"\" will remove the snapshot and return a Client to the base blob.\n     *\n     * @param snapshot - The snapshot timestamp.\n     * @returns A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.\n     */\n    withSnapshot(snapshot) {\n        return new AppendBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param options - Options to the Append Block Create operation.\n     *\n     *\n     * Example usage:\n     *\n     * ```js\n     * const appendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n     * await appendBlobClient.create();\n     * ```\n     */\n    async create(options = {}) {\n        var _a, _b, _c;\n        const { span, updatedOptions } = createSpan(\"AppendBlobClient-create\", options);\n        options.conditions = options.conditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.appendBlobContext.create(0, Object.assign({ abortSignal: options.abortSignal, blobHttpHeaders: options.blobHTTPHeaders, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, blobTagsString: toBlobTagsString(options.tags) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n     * If the blob with the same name already exists, the content of the existing blob will remain unchanged.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param options -\n     */\n    async createIfNotExists(options = {}) {\n        var _a, _b;\n        const { span, updatedOptions } = createSpan(\"AppendBlobClient-createIfNotExists\", options);\n        const conditions = { ifNoneMatch: ETagAny };\n        try {\n            const res = await this.create(Object.assign(Object.assign({}, updatedOptions), { conditions }));\n            return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });\n        }\n        catch (e) {\n            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobAlreadyExists\") {\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: \"Expected exception when creating a blob only if it does not already exist.\",\n                });\n                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Seals the append blob, making it read only.\n     *\n     * @param options -\n     */\n    async seal(options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"AppendBlobClient-seal\", options);\n        options.conditions = options.conditions || {};\n        try {\n            return await this.appendBlobContext.seal(Object.assign({ abortSignal: options.abortSignal, appendPositionAccessConditions: options.conditions, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Commits a new block of data to the end of the existing append blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/append-block\n     *\n     * @param body - Data to be appended.\n     * @param contentLength - Length of the body in bytes.\n     * @param options - Options to the Append Block operation.\n     *\n     *\n     * Example usage:\n     *\n     * ```js\n     * const content = \"Hello World!\";\n     *\n     * // Create a new append blob and append data to the blob.\n     * const newAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n     * await newAppendBlobClient.create();\n     * await newAppendBlobClient.appendBlock(content, content.length);\n     *\n     * // Append data to an existing append blob.\n     * const existingAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n     * await existingAppendBlobClient.appendBlock(content, content.length);\n     * ```\n     */\n    async appendBlock(body, contentLength, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"AppendBlobClient-appendBlock\", options);\n        options.conditions = options.conditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.appendBlobContext.appendBlock(contentLength, body, Object.assign({ abortSignal: options.abortSignal, appendPositionAccessConditions: options.conditions, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), requestOptions: {\n                    onUploadProgress: options.onProgress,\n                }, transactionalContentMD5: options.transactionalContentMD5, transactionalContentCrc64: options.transactionalContentCrc64, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * The Append Block operation commits a new block of data to the end of an existing append blob\n     * where the contents are read from a source url.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/append-block-from-url\n     *\n     * @param sourceURL -\n     *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can\n     *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob\n     *                 must either be public or must be authenticated via a shared access signature. If the source blob is\n     *                 public, no authentication is required to perform the operation.\n     * @param sourceOffset - Offset in source to be appended\n     * @param count - Number of bytes to be appended as a block\n     * @param options -\n     */\n    async appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"AppendBlobClient-appendBlockFromURL\", options);\n        options.conditions = options.conditions || {};\n        options.sourceConditions = options.sourceConditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, Object.assign({ abortSignal: options.abortSignal, sourceRange: rangeToString({ offset: sourceOffset, count }), sourceContentMD5: options.sourceContentMD5, sourceContentCrc64: options.sourceContentCrc64, leaseAccessConditions: options.conditions, appendPositionAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n                }, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n/**\n * BlockBlobClient defines a set of operations applicable to block blobs.\n */\nexport class BlockBlobClient extends BlobClient {\n    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n        //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n        let pipeline;\n        let url;\n        options = options || {};\n        if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n            // (url: string, pipeline: Pipeline)\n            url = urlOrConnectionString;\n            pipeline = credentialOrPipelineOrContainerName;\n        }\n        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n            isTokenCredential(credentialOrPipelineOrContainerName)) {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            url = urlOrConnectionString;\n            options = blobNameOrOptions;\n            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n        }\n        else if (!credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName !== \"string\") {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            // The second parameter is undefined. Use anonymous credential.\n            url = urlOrConnectionString;\n            pipeline = newPipeline(new AnonymousCredential(), options);\n        }\n        else if (credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName === \"string\" &&\n            blobNameOrOptions &&\n            typeof blobNameOrOptions === \"string\") {\n            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n            const containerName = credentialOrPipelineOrContainerName;\n            const blobName = blobNameOrOptions;\n            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n            if (extractedCreds.kind === \"AccountConnString\") {\n                if (isNode) {\n                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n                    if (!options.proxyOptions) {\n                        options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n                    }\n                    pipeline = newPipeline(sharedKeyCredential, options);\n                }\n                else {\n                    throw new Error(\"Account connection string is only supported in Node.js environment\");\n                }\n            }\n            else if (extractedCreds.kind === \"SASConnString\") {\n                url =\n                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +\n                        \"?\" +\n                        extractedCreds.accountSas;\n                pipeline = newPipeline(new AnonymousCredential(), options);\n            }\n            else {\n                throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n            }\n        }\n        else {\n            throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n        }\n        super(url, pipeline);\n        this.blockBlobContext = new BlockBlob(this.storageClientContext);\n        this._blobContext = new StorageBlob(this.storageClientContext);\n    }\n    /**\n     * Creates a new BlockBlobClient object identical to the source but with the\n     * specified snapshot timestamp.\n     * Provide \"\" will remove the snapshot and return a URL to the base blob.\n     *\n     * @param snapshot - The snapshot timestamp.\n     * @returns A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.\n     */\n    withSnapshot(snapshot) {\n        return new BlockBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Quick query for a JSON or CSV formatted blob.\n     *\n     * Example usage (Node.js):\n     *\n     * ```js\n     * // Query and convert a blob to a string\n     * const queryBlockBlobResponse = await blockBlobClient.query(\"select * from BlobStorage\");\n     * const downloaded = (await streamToBuffer(queryBlockBlobResponse.readableStreamBody)).toString();\n     * console.log(\"Query blob content:\", downloaded);\n     *\n     * async function streamToBuffer(readableStream) {\n     *   return new Promise((resolve, reject) => {\n     *     const chunks = [];\n     *     readableStream.on(\"data\", (data) => {\n     *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n     *     });\n     *     readableStream.on(\"end\", () => {\n     *       resolve(Buffer.concat(chunks));\n     *     });\n     *     readableStream.on(\"error\", reject);\n     *   });\n     * }\n     * ```\n     *\n     * @param query -\n     * @param options -\n     */\n    async query(query, options = {}) {\n        var _a;\n        ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-query\", options);\n        try {\n            if (!isNode) {\n                throw new Error(\"This operation currently is only supported in Node.js.\");\n            }\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            const response = await this._blobContext.query(Object.assign({ abortSignal: options.abortSignal, queryRequest: {\n                    queryType: \"SQL\",\n                    expression: query,\n                    inputSerialization: toQuerySerialization(options.inputTextConfiguration),\n                    outputSerialization: toQuerySerialization(options.outputTextConfiguration),\n                }, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey }, convertTracingToRequestOptionsBase(updatedOptions)));\n            return new BlobQueryResponse(response, {\n                abortSignal: options.abortSignal,\n                onProgress: options.onProgress,\n                onError: options.onError,\n            });\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a new block blob, or updates the content of an existing block blob.\n     * Updating an existing block blob overwrites any existing metadata on the blob.\n     * Partial updates are not supported; the content of the existing blob is\n     * overwritten with the new content. To perform a partial update of a block blob's,\n     * use {@link stageBlock} and {@link commitBlockList}.\n     *\n     * This is a non-parallel uploading method, please use {@link uploadFile},\n     * {@link uploadStream} or {@link uploadBrowserData} for better performance\n     * with concurrency uploading.\n     *\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n     *                               which returns a new Readable stream whose offset is from data source beginning.\n     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n     *                               string including non non-Base64/Hex-encoded characters.\n     * @param options - Options to the Block Blob Upload operation.\n     * @returns Response data for the Block Blob Upload operation.\n     *\n     * Example usage:\n     *\n     * ```js\n     * const content = \"Hello world!\";\n     * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n     * ```\n     */\n    async upload(body, contentLength, options = {}) {\n        var _a, _b, _c;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-upload\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blockBlobContext.upload(contentLength, body, Object.assign({ abortSignal: options.abortSignal, blobHttpHeaders: options.blobHTTPHeaders, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), requestOptions: {\n                    onUploadProgress: options.onProgress,\n                }, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a new Block Blob where the contents of the blob are read from a given URL.\n     * This API is supported beginning with the 2020-04-08 version. Partial updates\n     * are not supported with Put Blob from URL; the content of an existing blob is overwritten with\n     * the content of the new blob.  To perform partial updates to a block blobs contents using a\n     * source URL, use {@link stageBlockFromURL} and {@link commitBlockList}.\n     *\n     * @param sourceURL - Specifies the URL of the blob. The value\n     *                           may be a URL of up to 2 KB in length that specifies a blob.\n     *                           The value should be URL-encoded as it would appear\n     *                           in a request URI. The source blob must either be public\n     *                           or must be authenticated via a shared access signature.\n     *                           If the source blob is public, no authentication is required\n     *                           to perform the operation. Here are some examples of source object URLs:\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n     * @param options - Optional parameters.\n     */\n    async syncUploadFromURL(sourceURL, options = {}) {\n        var _a, _b, _c, _d, _e;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-syncUploadFromURL\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blockBlobContext.putBlobFromUrl(0, sourceURL, Object.assign(Object.assign(Object.assign({}, options), { blobHttpHeaders: options.blobHTTPHeaders, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: options.conditions.tagConditions }), sourceModifiedAccessConditions: {\n                    sourceIfMatch: (_a = options.sourceConditions) === null || _a === void 0 ? void 0 : _a.ifMatch,\n                    sourceIfModifiedSince: (_b = options.sourceConditions) === null || _b === void 0 ? void 0 : _b.ifModifiedSince,\n                    sourceIfNoneMatch: (_c = options.sourceConditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch,\n                    sourceIfUnmodifiedSince: (_d = options.sourceConditions) === null || _d === void 0 ? void 0 : _d.ifUnmodifiedSince,\n                    sourceIfTags: (_e = options.sourceConditions) === null || _e === void 0 ? void 0 : _e.tagConditions,\n                }, cpkInfo: options.customerProvidedKey, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization), tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags), copySourceTags: options.copySourceTags }), convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Uploads the specified block to the block blob's \"staging area\" to be later\n     * committed by a call to commitBlockList.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-block\n     *\n     * @param blockId - A 64-byte value that is base64-encoded\n     * @param body - Data to upload to the staging area.\n     * @param contentLength - Number of bytes to upload.\n     * @param options - Options to the Block Blob Stage Block operation.\n     * @returns Response data for the Block Blob Stage Block operation.\n     */\n    async stageBlock(blockId, body, contentLength, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-stageBlock\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blockBlobContext.stageBlock(blockId, contentLength, body, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, requestOptions: {\n                    onUploadProgress: options.onProgress,\n                }, transactionalContentMD5: options.transactionalContentMD5, transactionalContentCrc64: options.transactionalContentCrc64, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * The Stage Block From URL operation creates a new block to be committed as part\n     * of a blob where the contents are read from a URL.\n     * This API is available starting in version 2018-03-28.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-block-from-url\n     *\n     * @param blockId - A 64-byte value that is base64-encoded\n     * @param sourceURL - Specifies the URL of the blob. The value\n     *                           may be a URL of up to 2 KB in length that specifies a blob.\n     *                           The value should be URL-encoded as it would appear\n     *                           in a request URI. The source blob must either be public\n     *                           or must be authenticated via a shared access signature.\n     *                           If the source blob is public, no authentication is required\n     *                           to perform the operation. Here are some examples of source object URLs:\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n     * @param offset - From which position of the blob to download, greater than or equal to 0\n     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n     * @param options - Options to the Block Blob Stage Block From URL operation.\n     * @returns Response data for the Block Blob Stage Block From URL operation.\n     */\n    async stageBlockFromURL(blockId, sourceURL, offset = 0, count, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-stageBlockFromURL\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, sourceContentMD5: options.sourceContentMD5, sourceContentCrc64: options.sourceContentCrc64, sourceRange: offset === 0 && !count ? undefined : rangeToString({ offset, count }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Writes a blob by specifying the list of block IDs that make up the blob.\n     * In order to be written as part of a blob, a block must have been successfully written\n     * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to\n     * update a blob by uploading only those blocks that have changed, then committing the new and existing\n     * blocks together. Any blocks not specified in the block list and permanently deleted.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-block-list\n     *\n     * @param blocks -  Array of 64-byte value that is base64-encoded\n     * @param options - Options to the Block Blob Commit Block List operation.\n     * @returns Response data for the Block Blob Commit Block List operation.\n     */\n    async commitBlockList(blocks, options = {}) {\n        var _a, _b, _c;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-commitBlockList\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blockBlobContext.commitBlockList({ latest: blocks }, Object.assign({ abortSignal: options.abortSignal, blobHttpHeaders: options.blobHTTPHeaders, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns the list of blocks that have been uploaded as part of a block blob\n     * using the specified block list filter.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-block-list\n     *\n     * @param listType - Specifies whether to return the list of committed blocks,\n     *                                        the list of uncommitted blocks, or both lists together.\n     * @param options - Options to the Block Blob Get Block List operation.\n     * @returns Response data for the Block Blob Get Block List operation.\n     */\n    async getBlockList(listType, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-getBlockList\", options);\n        try {\n            const res = await this.blockBlobContext.getBlockList(listType, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n            if (!res.committedBlocks) {\n                res.committedBlocks = [];\n            }\n            if (!res.uncommittedBlocks) {\n                res.uncommittedBlocks = [];\n            }\n            return res;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    // High level functions\n    /**\n     * Uploads a Buffer(Node.js)/Blob(browsers)/ArrayBuffer/ArrayBufferView object to a BlockBlob.\n     *\n     * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n     * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n     * to commit the block list.\n     *\n     * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n     * `blobContentType`, enabling the browser to provide\n     * functionality based on file type.\n     *\n     * @param data - Buffer(Node.js), Blob, ArrayBuffer or ArrayBufferView\n     * @param options -\n     */\n    async uploadData(data, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadData\", options);\n        try {\n            if (isNode) {\n                let buffer;\n                if (data instanceof Buffer) {\n                    buffer = data;\n                }\n                else if (data instanceof ArrayBuffer) {\n                    buffer = Buffer.from(data);\n                }\n                else {\n                    data = data;\n                    buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n                }\n                return this.uploadSeekableInternal((offset, size) => buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);\n            }\n            else {\n                const browserBlob = new Blob([data]);\n                return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);\n            }\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * ONLY AVAILABLE IN BROWSERS.\n     *\n     * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.\n     *\n     * When buffer length lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call\n     * {@link commitBlockList} to commit the block list.\n     *\n     * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n     * `blobContentType`, enabling the browser to provide\n     * functionality based on file type.\n     *\n     * @deprecated Use {@link uploadData} instead.\n     *\n     * @param browserData - Blob, File, ArrayBuffer or ArrayBufferView\n     * @param options - Options to upload browser data.\n     * @returns Response data for the Blob Upload operation.\n     */\n    async uploadBrowserData(browserData, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadBrowserData\", options);\n        try {\n            const browserBlob = new Blob([browserData]);\n            return await this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     *\n     * Uploads data to block blob. Requires a bodyFactory as the data source,\n     * which need to return a {@link HttpRequestBody} object with the offset and size provided.\n     *\n     * When data length is no more than the specified {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n     * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n     * to commit the block list.\n     *\n     * @param bodyFactory -\n     * @param size - size of the data to upload.\n     * @param options - Options to Upload to Block Blob operation.\n     * @returns Response data for the Blob Upload operation.\n     */\n    async uploadSeekableInternal(bodyFactory, size, options = {}) {\n        if (!options.blockSize) {\n            options.blockSize = 0;\n        }\n        if (options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {\n            throw new RangeError(`blockSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);\n        }\n        if (options.maxSingleShotSize !== 0 && !options.maxSingleShotSize) {\n            options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;\n        }\n        if (options.maxSingleShotSize < 0 ||\n            options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {\n            throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);\n        }\n        if (options.blockSize === 0) {\n            if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS) {\n                throw new RangeError(`${size} is too larger to upload to a block blob.`);\n            }\n            if (size > options.maxSingleShotSize) {\n                options.blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);\n                if (options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {\n                    options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n                }\n            }\n        }\n        if (!options.blobHTTPHeaders) {\n            options.blobHTTPHeaders = {};\n        }\n        if (!options.conditions) {\n            options.conditions = {};\n        }\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadSeekableInternal\", options);\n        try {\n            if (size <= options.maxSingleShotSize) {\n                return await this.upload(bodyFactory(0, size), size, updatedOptions);\n            }\n            const numBlocks = Math.floor((size - 1) / options.blockSize) + 1;\n            if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {\n                throw new RangeError(`The buffer's size is too big or the BlockSize is too small;` +\n                    `the number of blocks must be <= ${BLOCK_BLOB_MAX_BLOCKS}`);\n            }\n            const blockList = [];\n            const blockIDPrefix = generateUuid();\n            let transferProgress = 0;\n            const batch = new Batch(options.concurrency);\n            for (let i = 0; i < numBlocks; i++) {\n                batch.addOperation(async () => {\n                    const blockID = generateBlockID(blockIDPrefix, i);\n                    const start = options.blockSize * i;\n                    const end = i === numBlocks - 1 ? size : start + options.blockSize;\n                    const contentLength = end - start;\n                    blockList.push(blockID);\n                    await this.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {\n                        abortSignal: options.abortSignal,\n                        conditions: options.conditions,\n                        encryptionScope: options.encryptionScope,\n                        tracingOptions: updatedOptions.tracingOptions,\n                    });\n                    // Update progress after block is successfully uploaded to server, in case of block trying\n                    // TODO: Hook with convenience layer progress event in finer level\n                    transferProgress += contentLength;\n                    if (options.onProgress) {\n                        options.onProgress({\n                            loadedBytes: transferProgress,\n                        });\n                    }\n                });\n            }\n            await batch.do();\n            return this.commitBlockList(blockList, updatedOptions);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Uploads a local file in blocks to a block blob.\n     *\n     * When file size lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n     * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList\n     * to commit the block list.\n     *\n     * @param filePath - Full path of local file\n     * @param options - Options to Upload to Block Blob operation.\n     * @returns Response data for the Blob Upload operation.\n     */\n    async uploadFile(filePath, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadFile\", options);\n        try {\n            const size = (await fsStat(filePath)).size;\n            return await this.uploadSeekableInternal((offset, count) => {\n                return () => fsCreateReadStream(filePath, {\n                    autoClose: true,\n                    end: count ? offset + count - 1 : Infinity,\n                    start: offset,\n                });\n            }, size, Object.assign(Object.assign({}, options), { tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions)) }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Uploads a Node.js Readable stream into block blob.\n     *\n     * PERFORMANCE IMPROVEMENT TIPS:\n     * * Input stream highWaterMark is better to set a same value with bufferSize\n     *    parameter, which will avoid Buffer.concat() operations.\n     *\n     * @param stream - Node.js Readable stream\n     * @param bufferSize - Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB\n     * @param maxConcurrency -  Max concurrency indicates the max number of buffers that can be allocated,\n     *                                 positive correlation with max uploading concurrency. Default value is 5\n     * @param options - Options to Upload Stream to Block Blob operation.\n     * @returns Response data for the Blob Upload operation.\n     */\n    async uploadStream(stream, bufferSize = DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {\n        if (!options.blobHTTPHeaders) {\n            options.blobHTTPHeaders = {};\n        }\n        if (!options.conditions) {\n            options.conditions = {};\n        }\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadStream\", options);\n        try {\n            let blockNum = 0;\n            const blockIDPrefix = generateUuid();\n            let transferProgress = 0;\n            const blockList = [];\n            const scheduler = new BufferScheduler(stream, bufferSize, maxConcurrency, async (body, length) => {\n                const blockID = generateBlockID(blockIDPrefix, blockNum);\n                blockList.push(blockID);\n                blockNum++;\n                await this.stageBlock(blockID, body, length, {\n                    conditions: options.conditions,\n                    encryptionScope: options.encryptionScope,\n                    tracingOptions: updatedOptions.tracingOptions,\n                });\n                // Update progress after block is successfully uploaded to server, in case of block trying\n                transferProgress += length;\n                if (options.onProgress) {\n                    options.onProgress({ loadedBytes: transferProgress });\n                }\n            }, \n            // concurrency should set a smaller value than maxConcurrency, which is helpful to\n            // reduce the possibility when a outgoing handler waits for stream data, in\n            // this situation, outgoing handlers are blocked.\n            // Outgoing queue shouldn't be empty.\n            Math.ceil((maxConcurrency / 4) * 3));\n            await scheduler.do();\n            return await this.commitBlockList(blockList, Object.assign(Object.assign({}, options), { tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions)) }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n/**\n * PageBlobClient defines a set of operations applicable to page blobs.\n */\nexport class PageBlobClient extends BlobClient {\n    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n        //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n        let pipeline;\n        let url;\n        options = options || {};\n        if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n            // (url: string, pipeline: Pipeline)\n            url = urlOrConnectionString;\n            pipeline = credentialOrPipelineOrContainerName;\n        }\n        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n            isTokenCredential(credentialOrPipelineOrContainerName)) {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            url = urlOrConnectionString;\n            options = blobNameOrOptions;\n            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n        }\n        else if (!credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName !== \"string\") {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            // The second parameter is undefined. Use anonymous credential.\n            url = urlOrConnectionString;\n            pipeline = newPipeline(new AnonymousCredential(), options);\n        }\n        else if (credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName === \"string\" &&\n            blobNameOrOptions &&\n            typeof blobNameOrOptions === \"string\") {\n            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n            const containerName = credentialOrPipelineOrContainerName;\n            const blobName = blobNameOrOptions;\n            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n            if (extractedCreds.kind === \"AccountConnString\") {\n                if (isNode) {\n                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n                    if (!options.proxyOptions) {\n                        options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n                    }\n                    pipeline = newPipeline(sharedKeyCredential, options);\n                }\n                else {\n                    throw new Error(\"Account connection string is only supported in Node.js environment\");\n                }\n            }\n            else if (extractedCreds.kind === \"SASConnString\") {\n                url =\n                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +\n                        \"?\" +\n                        extractedCreds.accountSas;\n                pipeline = newPipeline(new AnonymousCredential(), options);\n            }\n            else {\n                throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n            }\n        }\n        else {\n            throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n        }\n        super(url, pipeline);\n        this.pageBlobContext = new PageBlob(this.storageClientContext);\n    }\n    /**\n     * Creates a new PageBlobClient object identical to the source but with the\n     * specified snapshot timestamp.\n     * Provide \"\" will remove the snapshot and return a Client to the base blob.\n     *\n     * @param snapshot - The snapshot timestamp.\n     * @returns A new PageBlobClient object identical to the source but with the specified snapshot timestamp.\n     */\n    withSnapshot(snapshot) {\n        return new PageBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * Creates a page blob of the specified length. Call uploadPages to upload data\n     * data to a page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param size - size of the page blob.\n     * @param options - Options to the Page Blob Create operation.\n     * @returns Response data for the Page Blob Create operation.\n     */\n    async create(size, options = {}) {\n        var _a, _b, _c;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-create\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.pageBlobContext.create(0, size, Object.assign({ abortSignal: options.abortSignal, blobHttpHeaders: options.blobHTTPHeaders, blobSequenceNumber: options.blobSequenceNumber, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a page blob of the specified length. Call uploadPages to upload data\n     * data to a page blob. If the blob with the same name already exists, the content\n     * of the existing blob will remain unchanged.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param size - size of the page blob.\n     * @param options -\n     */\n    async createIfNotExists(size, options = {}) {\n        var _a, _b;\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-createIfNotExists\", options);\n        try {\n            const conditions = { ifNoneMatch: ETagAny };\n            const res = await this.create(size, Object.assign(Object.assign({}, options), { conditions, tracingOptions: updatedOptions.tracingOptions }));\n            return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });\n        }\n        catch (e) {\n            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobAlreadyExists\") {\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: \"Expected exception when creating a blob only if it does not already exist.\",\n                });\n                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n     *\n     * @param body - Data to upload\n     * @param offset - Offset of destination page blob\n     * @param count - Content length of the body, also number of bytes to be uploaded\n     * @param options - Options to the Page Blob Upload Pages operation.\n     * @returns Response data for the Page Blob Upload Pages operation.\n     */\n    async uploadPages(body, offset, count, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-uploadPages\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.pageBlobContext.uploadPages(count, body, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), requestOptions: {\n                    onUploadProgress: options.onProgress,\n                }, range: rangeToString({ offset, count }), sequenceNumberAccessConditions: options.conditions, transactionalContentMD5: options.transactionalContentMD5, transactionalContentCrc64: options.transactionalContentCrc64, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * The Upload Pages operation writes a range of pages to a page blob where the\n     * contents are read from a URL.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-page-from-url\n     *\n     * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication\n     * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source page blob\n     * @param destOffset - Offset of destination page blob\n     * @param count - Number of bytes to be uploaded from source page blob\n     * @param options -\n     */\n    async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        options.sourceConditions = options.sourceConditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-uploadPagesFromURL\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({ offset: sourceOffset, count }), 0, rangeToString({ offset: destOffset, count }), Object.assign({ abortSignal: options.abortSignal, sourceContentMD5: options.sourceContentMD5, sourceContentCrc64: options.sourceContentCrc64, leaseAccessConditions: options.conditions, sequenceNumberAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n                }, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Frees the specified pages from the page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n     *\n     * @param offset - Starting byte position of the pages to clear.\n     * @param count - Number of bytes to clear.\n     * @param options - Options to the Page Blob Clear Pages operation.\n     * @returns Response data for the Page Blob Clear Pages operation.\n     */\n    async clearPages(offset = 0, count, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-clearPages\", options);\n        try {\n            return await this.pageBlobContext.clearPages(0, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), range: rangeToString({ offset, count }), sequenceNumberAccessConditions: options.conditions, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns the list of valid page ranges for a page blob or snapshot of a page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param options - Options to the Page Blob Get Ranges operation.\n     * @returns Response data for the Page Blob Get Ranges operation.\n     */\n    async getPageRanges(offset = 0, count, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-getPageRanges\", options);\n        try {\n            return await this.pageBlobContext\n                .getPageRanges(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), range: rangeToString({ offset, count }) }, convertTracingToRequestOptionsBase(updatedOptions)))\n                .then(rangeResponseFromModel);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * getPageRangesSegment returns a single segment of page ranges starting from the\n     * specified Marker. Use an empty Marker to start enumeration from the beginning.\n     * After getting a segment, process it, and then call getPageRangesSegment again\n     * (passing the the previously-returned Marker) to get the next segment.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n     * @param options - Options to PageBlob Get Page Ranges Segment operation.\n     */\n    async listPageRangesSegment(offset = 0, count, marker, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-getPageRangesSegment\", options);\n        try {\n            return await this.pageBlobContext.getPageRanges(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), range: rangeToString({ offset, count }), marker: marker, maxPageSize: options.maxPageSize }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesResponseModel}\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param marker - A string value that identifies the portion of\n     *                          the get of page ranges to be returned with the next getting operation. The\n     *                          operation returns the ContinuationToken value within the response body if the\n     *                          getting operation did not return all page ranges remaining within the current page.\n     *                          The ContinuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of get\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to List Page Ranges operation.\n     */\n    listPageRangeItemSegments(offset = 0, count, marker, options = {}) {\n        return __asyncGenerator(this, arguments, function* listPageRangeItemSegments_1() {\n            let getPageRangeItemSegmentsResponse;\n            if (!!marker || marker === undefined) {\n                do {\n                    getPageRangeItemSegmentsResponse = yield __await(this.listPageRangesSegment(offset, count, marker, options));\n                    marker = getPageRangeItemSegmentsResponse.continuationToken;\n                    yield yield __await(yield __await(getPageRangeItemSegmentsResponse));\n                } while (marker);\n            }\n        });\n    }\n    /**\n     * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param options - Options to List Page Ranges operation.\n     */\n    listPageRangeItems(offset = 0, count, options = {}) {\n        return __asyncGenerator(this, arguments, function* listPageRangeItems_1() {\n            var e_1, _a;\n            let marker;\n            try {\n                for (var _b = __asyncValues(this.listPageRangeItemSegments(offset, count, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n                    const getPageRangesSegment = _c.value;\n                    yield __await(yield* __asyncDelegator(__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))));\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        });\n    }\n    /**\n     * Returns an async iterable iterator to list of page ranges for a page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     *  .byPage() returns an async iterable iterator to list of page ranges for a page blob.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * // Get the pageBlobClient before you run these snippets,\n     * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\").getPageBlobClient(\"<your-blob-name>\");`\n     * let i = 1;\n     * for await (const pageRange of pageBlobClient.listPageRanges()) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * let iter = pageBlobClient.listPageRanges();\n     * let pageRangeItem = await iter.next();\n     * while (!pageRangeItem.done) {\n     *   console.log(`Page range ${i++}: ${pageRangeItem.value.start} - ${pageRangeItem.value.end}, IsClear: ${pageRangeItem.value.isClear}`);\n     *   pageRangeItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of pageBlobClient.listPageRanges().byPage({ maxPageSize: 20 })) {\n     *   for (const pageRange of response) {\n     *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = pageBlobClient.listPageRanges().byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 page ranges\n     * for (const pageRange of response) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     *\n     * // Passing next marker as continuationToken\n     *\n     * iterator = pageBlobClient.listPageRanges().byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints 10 page ranges\n     * for (const blob of response) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     * ```\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param options - Options to the Page Blob Get Ranges operation.\n     * @returns An asyncIterableIterator that supports paging.\n     */\n    listPageRanges(offset = 0, count, options = {}) {\n        options.conditions = options.conditions || {};\n        // AsyncIterableIterator to iterate over blobs\n        const iter = this.listPageRangeItems(offset, count, options);\n        return {\n            /**\n             * The next method, part of the iteration protocol\n             */\n            next() {\n                return iter.next();\n            },\n            /**\n             * The connection to the async iterator, part of the iteration protocol\n             */\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n            /**\n             * Return an AsyncIterableIterator that works a page at a time\n             */\n            byPage: (settings = {}) => {\n                return this.listPageRangeItemSegments(offset, count, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));\n            },\n        };\n    }\n    /**\n     * Gets the collection of page ranges that differ between a specified snapshot and this page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page blob\n     * @param count - Number of bytes to get ranges diff.\n     * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     * @returns Response data for the Page Blob Get Page Range Diff operation.\n     */\n    async getPageRangesDiff(offset, count, prevSnapshot, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-getPageRangesDiff\", options);\n        try {\n            return await this.pageBlobContext\n                .getPageRangesDiff(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), prevsnapshot: prevSnapshot, range: rangeToString({ offset, count }) }, convertTracingToRequestOptionsBase(updatedOptions)))\n                .then(rangeResponseFromModel);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * getPageRangesDiffSegment returns a single segment of page ranges starting from the\n     * specified Marker for difference between previous snapshot and the target page blob.\n     * Use an empty Marker to start enumeration from the beginning.\n     * After getting a segment, process it, and then call getPageRangesDiffSegment again\n     * (passing the the previously-returned Marker) to get the next segment.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n     * @param marker - A string value that identifies the portion of the get to be returned with the next get operation.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     */\n    async listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-getPageRangesDiffSegment\", options);\n        try {\n            return await this.pageBlobContext.getPageRangesDiff(Object.assign({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal, leaseAccessConditions: options === null || options === void 0 ? void 0 : options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.conditions), { ifTags: (_a = options === null || options === void 0 ? void 0 : options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), prevsnapshot: prevSnapshotOrUrl, range: rangeToString({\n                    offset: offset,\n                    count: count,\n                }), marker: marker, maxPageSize: options === null || options === void 0 ? void 0 : options.maxPageSize }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesDiffResponseModel}\n     *\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n     * @param marker - A string value that identifies the portion of\n     *                          the get of page ranges to be returned with the next getting operation. The\n     *                          operation returns the ContinuationToken value within the response body if the\n     *                          getting operation did not return all page ranges remaining within the current page.\n     *                          The ContinuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of get\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     */\n    listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options) {\n        return __asyncGenerator(this, arguments, function* listPageRangeDiffItemSegments_1() {\n            let getPageRangeItemSegmentsResponse;\n            if (!!marker || marker === undefined) {\n                do {\n                    getPageRangeItemSegmentsResponse = yield __await(this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options));\n                    marker = getPageRangeItemSegmentsResponse.continuationToken;\n                    yield yield __await(yield __await(getPageRangeItemSegmentsResponse));\n                } while (marker);\n            }\n        });\n    }\n    /**\n     * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     */\n    listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options) {\n        return __asyncGenerator(this, arguments, function* listPageRangeDiffItems_1() {\n            var e_2, _a;\n            let marker;\n            try {\n                for (var _b = __asyncValues(this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n                    const getPageRangesSegment = _c.value;\n                    yield __await(yield* __asyncDelegator(__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))));\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        });\n    }\n    /**\n     * Returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     *  .byPage() returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * // Get the pageBlobClient before you run these snippets,\n     * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\").getPageBlobClient(\"<your-blob-name>\");`\n     * let i = 1;\n     * for await (const pageRange of pageBlobClient.listPageRangesDiff()) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * let iter = pageBlobClient.listPageRangesDiff();\n     * let pageRangeItem = await iter.next();\n     * while (!pageRangeItem.done) {\n     *   console.log(`Page range ${i++}: ${pageRangeItem.value.start} - ${pageRangeItem.value.end}, IsClear: ${pageRangeItem.value.isClear}`);\n     *   pageRangeItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of pageBlobClient.listPageRangesDiff().byPage({ maxPageSize: 20 })) {\n     *   for (const pageRange of response) {\n     *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = pageBlobClient.listPageRangesDiff().byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 page ranges\n     * for (const pageRange of response) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     *\n     * // Passing next marker as continuationToken\n     *\n     * iterator = pageBlobClient.listPageRangesDiff().byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints 10 page ranges\n     * for (const blob of response) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     * ```\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.\n     * @param options - Options to the Page Blob Get Ranges operation.\n     * @returns An asyncIterableIterator that supports paging.\n     */\n    listPageRangesDiff(offset, count, prevSnapshot, options = {}) {\n        options.conditions = options.conditions || {};\n        // AsyncIterableIterator to iterate over blobs\n        const iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, Object.assign({}, options));\n        return {\n            /**\n             * The next method, part of the iteration protocol\n             */\n            next() {\n                return iter.next();\n            },\n            /**\n             * The connection to the async iterator, part of the iteration protocol\n             */\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n            /**\n             * Return an AsyncIterableIterator that works a page at a time\n             */\n            byPage: (settings = {}) => {\n                return this.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));\n            },\n        };\n    }\n    /**\n     * Gets the collection of page ranges that differ between a specified snapshot and this page blob for managed disks.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page blob\n     * @param count - Number of bytes to get ranges diff.\n     * @param prevSnapshotUrl - URL of snapshot to retrieve the difference.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     * @returns Response data for the Page Blob Get Page Range Diff operation.\n     */\n    async getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-GetPageRangesDiffForManagedDisks\", options);\n        try {\n            return await this.pageBlobContext\n                .getPageRangesDiff(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), prevSnapshotUrl, range: rangeToString({ offset, count }) }, convertTracingToRequestOptionsBase(updatedOptions)))\n                .then(rangeResponseFromModel);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Resizes the page blob to the specified size (which must be a multiple of 512).\n     * @see https://docs.microsoft.com/rest/api/storageservices/set-blob-properties\n     *\n     * @param size - Target size\n     * @param options - Options to the Page Blob Resize operation.\n     * @returns Response data for the Page Blob Resize operation.\n     */\n    async resize(size, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-resize\", options);\n        try {\n            return await this.pageBlobContext.resize(size, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets a page blob's sequence number.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n     *\n     * @param sequenceNumberAction - Indicates how the service should modify the blob's sequence number.\n     * @param sequenceNumber - Required if sequenceNumberAction is max or update\n     * @param options - Options to the Page Blob Update Sequence Number operation.\n     * @returns Response data for the Page Blob Update Sequence Number operation.\n     */\n    async updateSequenceNumber(sequenceNumberAction, sequenceNumber, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-updateSequenceNumber\", options);\n        try {\n            return await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, Object.assign({ abortSignal: options.abortSignal, blobSequenceNumber: sequenceNumber, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.\n     * The snapshot is copied such that only the differential changes between the previously\n     * copied snapshot are transferred to the destination.\n     * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.\n     * @see https://docs.microsoft.com/rest/api/storageservices/incremental-copy-blob\n     * @see https://docs.microsoft.com/en-us/azure/virtual-machines/windows/incremental-snapshots\n     *\n     * @param copySource - Specifies the name of the source page blob snapshot. For example,\n     *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n     * @param options - Options to the Page Blob Copy Incremental operation.\n     * @returns Response data for the Page Blob Copy Incremental operation.\n     */\n    async startCopyIncremental(copySource, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-startCopyIncremental\", options);\n        try {\n            return await this.pageBlobContext.copyIncremental(copySource, Object.assign({ abortSignal: options.abortSignal, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message,\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n//# sourceMappingURL=Clients.js.map"]},"metadata":{},"sourceType":"module"}