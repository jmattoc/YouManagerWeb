{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Equipo/source/Tgsc-Proyectos/youManager-web/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { SpanKind, SpanStatusCode, createSpanFunction, getTraceParentHeader, isSpanContextValid } from \"@azure/core-tracing\";\nimport { logger } from \"../log\";\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\"\n});\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\n\nexport function tracingPolicy(tracingOptions = {}) {\n  return {\n    create(nextPolicy, options) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    }\n\n  };\n}\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\n\nexport class TracingPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, tracingOptions) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n\n  sendRequest(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!request.tracingContext) {\n        return _this._nextPolicy.sendRequest(request);\n      }\n\n      const span = _this.tryCreateSpan(request);\n\n      if (!span) {\n        return _this._nextPolicy.sendRequest(request);\n      }\n\n      try {\n        const response = yield _this._nextPolicy.sendRequest(request);\n\n        _this.tryProcessResponse(span, response);\n\n        return response;\n      } catch (err) {\n        _this.tryProcessError(span, err);\n\n        throw err;\n      }\n    })();\n  }\n\n  tryCreateSpan(request) {\n    var _a;\n\n    try {\n      // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n      // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n      const {\n        span\n      } = createSpan(`HTTP ${request.method}`, {\n        tracingOptions: {\n          spanOptions: Object.assign(Object.assign({}, request.spanOptions), {\n            kind: SpanKind.CLIENT\n          }),\n          tracingContext: request.tracingContext\n        }\n      }); // If the span is not recording, don't do any more work.\n\n      if (!span.isRecording()) {\n        span.end();\n        return undefined;\n      }\n\n      const namespaceFromContext = (_a = request.tracingContext) === null || _a === void 0 ? void 0 : _a.getValue(Symbol.for(\"az.namespace\"));\n\n      if (typeof namespaceFromContext === \"string\") {\n        span.setAttribute(\"az.namespace\", namespaceFromContext);\n      }\n\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId\n      });\n\n      if (this.userAgent) {\n        span.setAttribute(\"http.user_agent\", this.userAgent);\n      } // set headers\n\n\n      const spanContext = span.spanContext();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n\n      if (traceParentHeader && isSpanContextValid(spanContext)) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize(); // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n\n      return span;\n    } catch (error) {\n      logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n      return undefined;\n    }\n  }\n\n  tryProcessError(span, err) {\n    try {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message\n      });\n\n      if (err.statusCode) {\n        span.setAttribute(\"http.status_code\", err.statusCode);\n      }\n\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n\n  tryProcessResponse(span, response) {\n    try {\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n\n      span.setStatus({\n        code: SpanStatusCode.OK\n      });\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n\n} //# sourceMappingURL=tracingPolicy.js.map","map":{"version":3,"sources":["C:/Users/Equipo/source/Tgsc-Proyectos/youManager-web/node_modules/@azure/core-http/dist-esm/src/policies/tracingPolicy.js"],"names":["BaseRequestPolicy","SpanKind","SpanStatusCode","createSpanFunction","getTraceParentHeader","isSpanContextValid","logger","createSpan","packagePrefix","namespace","tracingPolicy","tracingOptions","create","nextPolicy","options","TracingPolicy","constructor","userAgent","sendRequest","request","tracingContext","_nextPolicy","span","tryCreateSpan","response","tryProcessResponse","err","tryProcessError","_a","method","spanOptions","Object","assign","kind","CLIENT","isRecording","end","undefined","namespaceFromContext","getValue","Symbol","for","setAttribute","setAttributes","url","requestId","spanContext","traceParentHeader","headers","set","traceState","serialize","error","warning","message","setStatus","code","ERROR","statusCode","status","serviceRequestId","get","OK"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy, } from \"./requestPolicy\";\nimport { SpanKind, SpanStatusCode, createSpanFunction, getTraceParentHeader, isSpanContextValid, } from \"@azure/core-tracing\";\nimport { logger } from \"../log\";\nconst createSpan = createSpanFunction({\n    packagePrefix: \"\",\n    namespace: \"\",\n});\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\nexport function tracingPolicy(tracingOptions = {}) {\n    return {\n        create(nextPolicy, options) {\n            return new TracingPolicy(nextPolicy, options, tracingOptions);\n        },\n    };\n}\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\nexport class TracingPolicy extends BaseRequestPolicy {\n    constructor(nextPolicy, options, tracingOptions) {\n        super(nextPolicy, options);\n        this.userAgent = tracingOptions.userAgent;\n    }\n    async sendRequest(request) {\n        if (!request.tracingContext) {\n            return this._nextPolicy.sendRequest(request);\n        }\n        const span = this.tryCreateSpan(request);\n        if (!span) {\n            return this._nextPolicy.sendRequest(request);\n        }\n        try {\n            const response = await this._nextPolicy.sendRequest(request);\n            this.tryProcessResponse(span, response);\n            return response;\n        }\n        catch (err) {\n            this.tryProcessError(span, err);\n            throw err;\n        }\n    }\n    tryCreateSpan(request) {\n        var _a;\n        try {\n            // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n            // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n            const { span } = createSpan(`HTTP ${request.method}`, {\n                tracingOptions: {\n                    spanOptions: Object.assign(Object.assign({}, request.spanOptions), { kind: SpanKind.CLIENT }),\n                    tracingContext: request.tracingContext,\n                },\n            });\n            // If the span is not recording, don't do any more work.\n            if (!span.isRecording()) {\n                span.end();\n                return undefined;\n            }\n            const namespaceFromContext = (_a = request.tracingContext) === null || _a === void 0 ? void 0 : _a.getValue(Symbol.for(\"az.namespace\"));\n            if (typeof namespaceFromContext === \"string\") {\n                span.setAttribute(\"az.namespace\", namespaceFromContext);\n            }\n            span.setAttributes({\n                \"http.method\": request.method,\n                \"http.url\": request.url,\n                requestId: request.requestId,\n            });\n            if (this.userAgent) {\n                span.setAttribute(\"http.user_agent\", this.userAgent);\n            }\n            // set headers\n            const spanContext = span.spanContext();\n            const traceParentHeader = getTraceParentHeader(spanContext);\n            if (traceParentHeader && isSpanContextValid(spanContext)) {\n                request.headers.set(\"traceparent\", traceParentHeader);\n                const traceState = spanContext.traceState && spanContext.traceState.serialize();\n                // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n                if (traceState) {\n                    request.headers.set(\"tracestate\", traceState);\n                }\n            }\n            return span;\n        }\n        catch (error) {\n            logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n            return undefined;\n        }\n    }\n    tryProcessError(span, err) {\n        try {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: err.message,\n            });\n            if (err.statusCode) {\n                span.setAttribute(\"http.status_code\", err.statusCode);\n            }\n            span.end();\n        }\n        catch (error) {\n            logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n        }\n    }\n    tryProcessResponse(span, response) {\n        try {\n            span.setAttribute(\"http.status_code\", response.status);\n            const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n            if (serviceRequestId) {\n                span.setAttribute(\"serviceRequestId\", serviceRequestId);\n            }\n            span.setStatus({\n                code: SpanStatusCode.OK,\n            });\n            span.end();\n        }\n        catch (error) {\n            logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n        }\n    }\n}\n//# sourceMappingURL=tracingPolicy.js.map"]},"metadata":{},"sourceType":"module"}