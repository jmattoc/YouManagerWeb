{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\n/**\n * returns an async iterator that iterates over results. It also has a `byPage`\n * method that returns pages of items at once.\n *\n * @param pagedResult - an object that specifies how to get pages.\n * @returns a paged async iterator that iterates over results.\n */\n\nexport function getPagedAsyncIterator(pagedResult) {\n  var _a;\n\n  const iter = getItemAsyncIterator(pagedResult);\n  return {\n    next() {\n      return iter.next();\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    byPage: (_a = pagedResult === null || pagedResult === void 0 ? void 0 : pagedResult.byPage) !== null && _a !== void 0 ? _a : settings => {\n      const {\n        continuationToken,\n        maxPageSize\n      } = settings !== null && settings !== void 0 ? settings : {};\n      return getPageAsyncIterator(pagedResult, {\n        pageLink: continuationToken,\n        maxPageSize\n      });\n    }\n  };\n}\n\nfunction getItemAsyncIterator(pagedResult) {\n  return __asyncGenerator(this, arguments, function* getItemAsyncIterator_1() {\n    var e_1, _a;\n\n    const pages = getPageAsyncIterator(pagedResult);\n    const firstVal = yield __await(pages.next()); // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is\n\n    if (!Array.isArray(firstVal.value)) {\n      yield yield __await(firstVal.value); // `pages` is of type `AsyncIterableIterator<TPage>` but TPage = TElement in this case\n\n      yield __await(yield* __asyncDelegator(__asyncValues(pages)));\n    } else {\n      yield __await(yield* __asyncDelegator(__asyncValues(firstVal.value)));\n\n      try {\n        for (var pages_1 = __asyncValues(pages), pages_1_1; pages_1_1 = yield __await(pages_1.next()), !pages_1_1.done;) {\n          const page = pages_1_1.value; // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,\n          // it must be the case that `TPage = TElement[]`\n\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (pages_1_1 && !pages_1_1.done && (_a = pages_1.return)) yield __await(_a.call(pages_1));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n  });\n}\n\nfunction getPageAsyncIterator(pagedResult, options = {}) {\n  return __asyncGenerator(this, arguments, function* getPageAsyncIterator_1() {\n    const {\n      pageLink,\n      maxPageSize\n    } = options;\n    let response = yield __await(pagedResult.getPage(pageLink !== null && pageLink !== void 0 ? pageLink : pagedResult.firstPageLink, maxPageSize));\n    yield yield __await(response.page);\n\n    while (response.nextPageLink) {\n      response = yield __await(pagedResult.getPage(response.nextPageLink, maxPageSize));\n      yield yield __await(response.page);\n    }\n  });\n} //# sourceMappingURL=getPagedAsyncIterator.js.map","map":{"version":3,"sources":["C:/Users/Equipo/source/Tgsc-Proyectos/rrhh-web/node_modules/@azure/core-paging/dist-esm/src/getPagedAsyncIterator.js"],"names":["__asyncDelegator","__asyncGenerator","__asyncValues","__await","getPagedAsyncIterator","pagedResult","_a","iter","getItemAsyncIterator","next","Symbol","asyncIterator","byPage","settings","continuationToken","maxPageSize","getPageAsyncIterator","pageLink","arguments","getItemAsyncIterator_1","e_1","pages","firstVal","Array","isArray","value","pages_1","pages_1_1","done","page","e_1_1","error","return","call","options","getPageAsyncIterator_1","response","getPage","firstPageLink","nextPageLink"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\n/**\n * returns an async iterator that iterates over results. It also has a `byPage`\n * method that returns pages of items at once.\n *\n * @param pagedResult - an object that specifies how to get pages.\n * @returns a paged async iterator that iterates over results.\n */\nexport function getPagedAsyncIterator(pagedResult) {\n    var _a;\n    const iter = getItemAsyncIterator(pagedResult);\n    return {\n        next() {\n            return iter.next();\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        byPage: (_a = pagedResult === null || pagedResult === void 0 ? void 0 : pagedResult.byPage) !== null && _a !== void 0 ? _a : ((settings) => {\n            const { continuationToken, maxPageSize } = settings !== null && settings !== void 0 ? settings : {};\n            return getPageAsyncIterator(pagedResult, {\n                pageLink: continuationToken,\n                maxPageSize,\n            });\n        }),\n    };\n}\nfunction getItemAsyncIterator(pagedResult) {\n    return __asyncGenerator(this, arguments, function* getItemAsyncIterator_1() {\n        var e_1, _a;\n        const pages = getPageAsyncIterator(pagedResult);\n        const firstVal = yield __await(pages.next());\n        // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is\n        if (!Array.isArray(firstVal.value)) {\n            yield yield __await(firstVal.value);\n            // `pages` is of type `AsyncIterableIterator<TPage>` but TPage = TElement in this case\n            yield __await(yield* __asyncDelegator(__asyncValues(pages)));\n        }\n        else {\n            yield __await(yield* __asyncDelegator(__asyncValues(firstVal.value)));\n            try {\n                for (var pages_1 = __asyncValues(pages), pages_1_1; pages_1_1 = yield __await(pages_1.next()), !pages_1_1.done;) {\n                    const page = pages_1_1.value;\n                    // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,\n                    // it must be the case that `TPage = TElement[]`\n                    yield __await(yield* __asyncDelegator(__asyncValues(page)));\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (pages_1_1 && !pages_1_1.done && (_a = pages_1.return)) yield __await(_a.call(pages_1));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n    });\n}\nfunction getPageAsyncIterator(pagedResult, options = {}) {\n    return __asyncGenerator(this, arguments, function* getPageAsyncIterator_1() {\n        const { pageLink, maxPageSize } = options;\n        let response = yield __await(pagedResult.getPage(pageLink !== null && pageLink !== void 0 ? pageLink : pagedResult.firstPageLink, maxPageSize));\n        yield yield __await(response.page);\n        while (response.nextPageLink) {\n            response = yield __await(pagedResult.getPage(response.nextPageLink, maxPageSize));\n            yield yield __await(response.page);\n        }\n    });\n}\n//# sourceMappingURL=getPagedAsyncIterator.js.map"]},"metadata":{},"sourceType":"module"}