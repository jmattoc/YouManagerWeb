{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Equipo/source/Tgsc-Proyectos/rrhh-web/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortController } from \"@azure/abort-controller\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delayMs } from \"./util/delayMs\";\n\nconst createStateProxy = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: config => ({\n    status: \"running\",\n    config\n  }),\n  setCanceled: state => state.status = \"canceled\",\n  setError: (state, error) => state.error = error,\n  setResult: (state, result) => state.result = result,\n  setRunning: state => state.status = \"running\",\n  setSucceeded: state => state.status = \"succeeded\",\n  setFailed: state => state.status = \"failed\",\n  getError: state => state.error,\n  getResult: state => state.result,\n  isCanceled: state => state.status === \"canceled\",\n  isFailed: state => state.status === \"failed\",\n  isRunning: state => state.status === \"running\",\n  isSucceeded: state => state.status === \"succeeded\"\n});\n/**\n * Returns a poller factory.\n */\n\n\nexport function buildCreatePoller(inputs) {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    getResourceLocation,\n    getPollingInterval\n  } = inputs;\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* ({\n      init,\n      poll\n    }, options) {\n      const {\n        processResult,\n        updateState,\n        withOperationLocation: withOperationLocationCallback,\n        intervalInMs = POLL_INTERVAL_IN_MS,\n        restoreFrom\n      } = options || {};\n      const stateProxy = createStateProxy();\n      const withOperationLocation = withOperationLocationCallback ? (() => {\n        let called = false;\n        return (operationLocation, isUpdated) => {\n          if (isUpdated) withOperationLocationCallback(operationLocation);else if (!called) withOperationLocationCallback(operationLocation);\n          called = true;\n        };\n      })() : undefined;\n      const state = restoreFrom ? deserializeState(restoreFrom) : yield initOperation({\n        init,\n        stateProxy,\n        processResult,\n        getOperationStatus: getStatusFromInitialResponse,\n        withOperationLocation\n      });\n      let resultPromise;\n      let cancelJob;\n      const abortController = new AbortController();\n      const handlers = new Map();\n\n      const handleProgressEvents = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          return handlers.forEach(h => h(state));\n        });\n\n        return function handleProgressEvents() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      let currentPollIntervalInMs = intervalInMs;\n      const poller = {\n        getOperationState: () => state,\n        getResult: () => state.result,\n        isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n        isStopped: () => resultPromise === undefined,\n        stopPolling: () => {\n          abortController.abort();\n          cancelJob === null || cancelJob === void 0 ? void 0 : cancelJob();\n        },\n        toString: () => JSON.stringify({\n          state\n        }),\n        onProgress: callback => {\n          const s = Symbol();\n          handlers.set(s, callback);\n          return () => handlers.delete(s);\n        },\n        pollUntilDone: pollOptions => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = _asyncToGenerator(function* () {\n          const {\n            abortSignal: inputAbortSignal\n          } = pollOptions || {};\n          const {\n            signal: abortSignal\n          } = inputAbortSignal ? new AbortController([inputAbortSignal, abortController.signal]) : abortController;\n\n          if (!poller.isDone()) {\n            yield poller.poll({\n              abortSignal\n            });\n\n            while (!poller.isDone()) {\n              const delay = delayMs(currentPollIntervalInMs);\n              cancelJob = delay.cancel;\n              yield delay;\n              yield poller.poll({\n                abortSignal\n              });\n            }\n          }\n\n          switch (state.status) {\n            case \"succeeded\":\n              {\n                return poller.getResult();\n              }\n\n            case \"canceled\":\n              {\n                throw new Error(\"Operation was canceled\");\n              }\n\n            case \"failed\":\n              {\n                throw state.error;\n              }\n\n            case \"notStarted\":\n            case \"running\":\n              {\n                // Unreachable\n                throw new Error(`polling completed without succeeding or failing`);\n              }\n          }\n        })().finally(() => {\n          resultPromise = undefined;\n        }),\n\n        poll(pollOptions) {\n          return _asyncToGenerator(function* () {\n            yield pollOperation({\n              poll,\n              state,\n              stateProxy,\n              getOperationLocation,\n              withOperationLocation,\n              getPollingInterval,\n              getOperationStatus: getStatusFromPollResponse,\n              getResourceLocation,\n              processResult,\n              updateState,\n              options: pollOptions,\n              setDelay: pollIntervalInMs => {\n                currentPollIntervalInMs = pollIntervalInMs;\n              }\n            });\n            yield handleProgressEvents();\n\n            if (state.status === \"canceled\") {\n              throw new Error(\"Operation was canceled\");\n            }\n\n            if (state.status === \"failed\") {\n              throw state.error;\n            }\n          })();\n        }\n\n      };\n      return poller;\n    });\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n} //# sourceMappingURL=poller.js.map","map":{"version":3,"sources":["C:/Users/Equipo/source/Tgsc-Proyectos/rrhh-web/node_modules/@azure/core-lro/dist-esm/src/poller/poller.js"],"names":["AbortController","deserializeState","initOperation","pollOperation","POLL_INTERVAL_IN_MS","delayMs","createStateProxy","initState","config","status","setCanceled","state","setError","error","setResult","result","setRunning","setSucceeded","setFailed","getError","getResult","isCanceled","isFailed","isRunning","isSucceeded","buildCreatePoller","inputs","getOperationLocation","getStatusFromInitialResponse","getStatusFromPollResponse","getResourceLocation","getPollingInterval","init","poll","options","processResult","updateState","withOperationLocation","withOperationLocationCallback","intervalInMs","restoreFrom","stateProxy","called","operationLocation","isUpdated","undefined","getOperationStatus","resultPromise","cancelJob","abortController","handlers","Map","handleProgressEvents","forEach","h","currentPollIntervalInMs","poller","getOperationState","isDone","includes","isStopped","stopPolling","abort","toString","JSON","stringify","onProgress","callback","s","Symbol","set","delete","pollUntilDone","pollOptions","abortSignal","inputAbortSignal","signal","delay","cancel","Error","finally","setDelay","pollIntervalInMs"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortController } from \"@azure/abort-controller\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delayMs } from \"./util/delayMs\";\nconst createStateProxy = () => ({\n    /**\n     * The state at this point is created to be of type OperationState<TResult>.\n     * It will be updated later to be of type TState when the\n     * customer-provided callback, `updateState`, is called during polling.\n     */\n    initState: (config) => ({ status: \"running\", config }),\n    setCanceled: (state) => (state.status = \"canceled\"),\n    setError: (state, error) => (state.error = error),\n    setResult: (state, result) => (state.result = result),\n    setRunning: (state) => (state.status = \"running\"),\n    setSucceeded: (state) => (state.status = \"succeeded\"),\n    setFailed: (state) => (state.status = \"failed\"),\n    getError: (state) => state.error,\n    getResult: (state) => state.result,\n    isCanceled: (state) => state.status === \"canceled\",\n    isFailed: (state) => state.status === \"failed\",\n    isRunning: (state) => state.status === \"running\",\n    isSucceeded: (state) => state.status === \"succeeded\",\n});\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller(inputs) {\n    const { getOperationLocation, getStatusFromInitialResponse, getStatusFromPollResponse, getResourceLocation, getPollingInterval, } = inputs;\n    return async ({ init, poll }, options) => {\n        const { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = POLL_INTERVAL_IN_MS, restoreFrom, } = options || {};\n        const stateProxy = createStateProxy();\n        const withOperationLocation = withOperationLocationCallback\n            ? (() => {\n                let called = false;\n                return (operationLocation, isUpdated) => {\n                    if (isUpdated)\n                        withOperationLocationCallback(operationLocation);\n                    else if (!called)\n                        withOperationLocationCallback(operationLocation);\n                    called = true;\n                };\n            })()\n            : undefined;\n        const state = restoreFrom\n            ? deserializeState(restoreFrom)\n            : await initOperation({\n                init,\n                stateProxy,\n                processResult,\n                getOperationStatus: getStatusFromInitialResponse,\n                withOperationLocation,\n            });\n        let resultPromise;\n        let cancelJob;\n        const abortController = new AbortController();\n        const handlers = new Map();\n        const handleProgressEvents = async () => handlers.forEach((h) => h(state));\n        let currentPollIntervalInMs = intervalInMs;\n        const poller = {\n            getOperationState: () => state,\n            getResult: () => state.result,\n            isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n            isStopped: () => resultPromise === undefined,\n            stopPolling: () => {\n                abortController.abort();\n                cancelJob === null || cancelJob === void 0 ? void 0 : cancelJob();\n            },\n            toString: () => JSON.stringify({\n                state,\n            }),\n            onProgress: (callback) => {\n                const s = Symbol();\n                handlers.set(s, callback);\n                return () => handlers.delete(s);\n            },\n            pollUntilDone: (pollOptions) => (resultPromise !== null && resultPromise !== void 0 ? resultPromise : (resultPromise = (async () => {\n                const { abortSignal: inputAbortSignal } = pollOptions || {};\n                const { signal: abortSignal } = inputAbortSignal\n                    ? new AbortController([inputAbortSignal, abortController.signal])\n                    : abortController;\n                if (!poller.isDone()) {\n                    await poller.poll({ abortSignal });\n                    while (!poller.isDone()) {\n                        const delay = delayMs(currentPollIntervalInMs);\n                        cancelJob = delay.cancel;\n                        await delay;\n                        await poller.poll({ abortSignal });\n                    }\n                }\n                switch (state.status) {\n                    case \"succeeded\": {\n                        return poller.getResult();\n                    }\n                    case \"canceled\": {\n                        throw new Error(\"Operation was canceled\");\n                    }\n                    case \"failed\": {\n                        throw state.error;\n                    }\n                    case \"notStarted\":\n                    case \"running\": {\n                        // Unreachable\n                        throw new Error(`polling completed without succeeding or failing`);\n                    }\n                }\n            })().finally(() => {\n                resultPromise = undefined;\n            }))),\n            async poll(pollOptions) {\n                await pollOperation({\n                    poll,\n                    state,\n                    stateProxy,\n                    getOperationLocation,\n                    withOperationLocation,\n                    getPollingInterval,\n                    getOperationStatus: getStatusFromPollResponse,\n                    getResourceLocation,\n                    processResult,\n                    updateState,\n                    options: pollOptions,\n                    setDelay: (pollIntervalInMs) => {\n                        currentPollIntervalInMs = pollIntervalInMs;\n                    },\n                });\n                await handleProgressEvents();\n                if (state.status === \"canceled\") {\n                    throw new Error(\"Operation was canceled\");\n                }\n                if (state.status === \"failed\") {\n                    throw state.error;\n                }\n            },\n        };\n        return poller;\n    };\n}\n//# sourceMappingURL=poller.js.map"]},"metadata":{},"sourceType":"module"}