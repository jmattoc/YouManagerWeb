{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Equipo/source/Tgsc-Proyectos/rrhh-web/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n/**\n * Deserializes the state\n */\n\nexport function deserializeState(serializedState) {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`Unable to deserialize input state: ${serializedState}`);\n  }\n}\n\nfunction setStateError(inputs) {\n  const {\n    state,\n    stateProxy\n  } = inputs;\n  return error => {\n    stateProxy.setError(state, error);\n    stateProxy.setFailed(state);\n    throw error;\n  };\n}\n\nfunction processOperationStatus(result) {\n  const {\n    state,\n    stateProxy,\n    status\n  } = result;\n  logger.verbose(`LRO: Status:\\n\\tPolling from: ${state.config.operationLocation}\\n\\tOperation status: ${status}\\n\\tPolling status: ${terminalStates.includes(status) ? \"Stopped\" : \"Running\"}`);\n\n  switch (status) {\n    case \"succeeded\":\n      {\n        stateProxy.setSucceeded(state);\n        break;\n      }\n\n    case \"failed\":\n      {\n        stateProxy.setError(state, new Error(`The long-running operation has failed`));\n        stateProxy.setFailed(state);\n        break;\n      }\n\n    case \"canceled\":\n      {\n        stateProxy.setCanceled(state);\n        break;\n      }\n  }\n}\n\nfunction buildResult(inputs) {\n  const {\n    processResult,\n    response,\n    state\n  } = inputs;\n  return processResult ? processResult(response, state) : response;\n}\n/**\n * Initiates the long-running operation.\n */\n\n\nexport function initOperation(_x) {\n  return _initOperation.apply(this, arguments);\n}\n\nfunction _initOperation() {\n  _initOperation = _asyncToGenerator(function* (inputs) {\n    const {\n      init,\n      stateProxy,\n      processResult,\n      getOperationStatus,\n      withOperationLocation\n    } = inputs;\n    const {\n      operationLocation,\n      resourceLocation,\n      metadata,\n      response\n    } = yield init();\n    if (operationLocation) withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n    const config = {\n      metadata,\n      operationLocation,\n      resourceLocation\n    };\n    logger.verbose(`LRO: Operation description:`, config);\n    const state = stateProxy.initState(config);\n    const status = getOperationStatus(response, state);\n\n    if (status === \"succeeded\" || operationLocation === undefined) {\n      stateProxy.setSucceeded(state);\n      stateProxy.setResult(state, buildResult({\n        response,\n        state,\n        processResult\n      }));\n    }\n\n    return state;\n  });\n  return _initOperation.apply(this, arguments);\n}\n\nfunction pollOperationHelper(_x2) {\n  return _pollOperationHelper.apply(this, arguments);\n}\n/** Polls the long-running operation. */\n\n\nfunction _pollOperationHelper() {\n  _pollOperationHelper = _asyncToGenerator(function* (inputs) {\n    const {\n      poll,\n      state,\n      stateProxy,\n      operationLocation,\n      getOperationStatus,\n      getResourceLocation,\n      options\n    } = inputs;\n    const response = yield poll(operationLocation, options).catch(setStateError({\n      state,\n      stateProxy\n    }));\n    const status = getOperationStatus(response, state);\n    processOperationStatus({\n      status,\n      state,\n      stateProxy\n    });\n\n    if (status === \"succeeded\") {\n      const resourceLocation = getResourceLocation(response, state);\n\n      if (resourceLocation !== undefined) {\n        return {\n          response: yield poll(resourceLocation).catch(setStateError({\n            state,\n            stateProxy\n          })),\n          status\n        };\n      }\n    }\n\n    return {\n      response,\n      status\n    };\n  });\n  return _pollOperationHelper.apply(this, arguments);\n}\n\nexport function pollOperation(_x3) {\n  return _pollOperation.apply(this, arguments);\n} //# sourceMappingURL=operation.js.map\n\nfunction _pollOperation() {\n  _pollOperation = _asyncToGenerator(function* (inputs) {\n    const {\n      poll,\n      state,\n      stateProxy,\n      options,\n      getOperationStatus,\n      getResourceLocation,\n      getOperationLocation,\n      withOperationLocation,\n      getPollingInterval,\n      processResult,\n      updateState,\n      setDelay,\n      isDone\n    } = inputs;\n    const {\n      operationLocation\n    } = state.config;\n\n    if (operationLocation !== undefined) {\n      const {\n        response,\n        status\n      } = yield pollOperationHelper({\n        poll,\n        getOperationStatus,\n        state,\n        stateProxy,\n        operationLocation,\n        getResourceLocation,\n        options\n      });\n\n      if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === undefined && [\"succeeded\", \"canceled\"].includes(status)) {\n        stateProxy.setResult(state, buildResult({\n          response,\n          state,\n          processResult\n        }));\n      } else {\n        const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);\n        if (intervalInMs) setDelay(intervalInMs);\n        const location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);\n\n        if (location !== undefined) {\n          const isUpdated = operationLocation !== location;\n          state.config.operationLocation = location;\n          withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);\n        } else withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n      }\n\n      updateState === null || updateState === void 0 ? void 0 : updateState(state, response);\n    }\n  });\n  return _pollOperation.apply(this, arguments);\n}","map":{"version":3,"sources":["C:/Users/Equipo/source/Tgsc-Proyectos/rrhh-web/node_modules/@azure/core-lro/dist-esm/src/poller/operation.js"],"names":["logger","terminalStates","deserializeState","serializedState","JSON","parse","state","e","Error","setStateError","inputs","stateProxy","error","setError","setFailed","processOperationStatus","result","status","verbose","config","operationLocation","includes","setSucceeded","setCanceled","buildResult","processResult","response","initOperation","init","getOperationStatus","withOperationLocation","resourceLocation","metadata","initState","undefined","setResult","pollOperationHelper","poll","getResourceLocation","options","catch","pollOperation","getOperationLocation","getPollingInterval","updateState","setDelay","isDone","intervalInMs","location","isUpdated"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n/**\n * Deserializes the state\n */\nexport function deserializeState(serializedState) {\n    try {\n        return JSON.parse(serializedState).state;\n    }\n    catch (e) {\n        throw new Error(`Unable to deserialize input state: ${serializedState}`);\n    }\n}\nfunction setStateError(inputs) {\n    const { state, stateProxy } = inputs;\n    return (error) => {\n        stateProxy.setError(state, error);\n        stateProxy.setFailed(state);\n        throw error;\n    };\n}\nfunction processOperationStatus(result) {\n    const { state, stateProxy, status } = result;\n    logger.verbose(`LRO: Status:\\n\\tPolling from: ${state.config.operationLocation}\\n\\tOperation status: ${status}\\n\\tPolling status: ${terminalStates.includes(status) ? \"Stopped\" : \"Running\"}`);\n    switch (status) {\n        case \"succeeded\": {\n            stateProxy.setSucceeded(state);\n            break;\n        }\n        case \"failed\": {\n            stateProxy.setError(state, new Error(`The long-running operation has failed`));\n            stateProxy.setFailed(state);\n            break;\n        }\n        case \"canceled\": {\n            stateProxy.setCanceled(state);\n            break;\n        }\n    }\n}\nfunction buildResult(inputs) {\n    const { processResult, response, state } = inputs;\n    return processResult ? processResult(response, state) : response;\n}\n/**\n * Initiates the long-running operation.\n */\nexport async function initOperation(inputs) {\n    const { init, stateProxy, processResult, getOperationStatus, withOperationLocation } = inputs;\n    const { operationLocation, resourceLocation, metadata, response } = await init();\n    if (operationLocation)\n        withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n    const config = {\n        metadata,\n        operationLocation,\n        resourceLocation,\n    };\n    logger.verbose(`LRO: Operation description:`, config);\n    const state = stateProxy.initState(config);\n    const status = getOperationStatus(response, state);\n    if (status === \"succeeded\" || operationLocation === undefined) {\n        stateProxy.setSucceeded(state);\n        stateProxy.setResult(state, buildResult({\n            response,\n            state,\n            processResult,\n        }));\n    }\n    return state;\n}\nasync function pollOperationHelper(inputs) {\n    const { poll, state, stateProxy, operationLocation, getOperationStatus, getResourceLocation, options, } = inputs;\n    const response = await poll(operationLocation, options).catch(setStateError({\n        state,\n        stateProxy,\n    }));\n    const status = getOperationStatus(response, state);\n    processOperationStatus({\n        status,\n        state,\n        stateProxy,\n    });\n    if (status === \"succeeded\") {\n        const resourceLocation = getResourceLocation(response, state);\n        if (resourceLocation !== undefined) {\n            return {\n                response: await poll(resourceLocation).catch(setStateError({ state, stateProxy })),\n                status,\n            };\n        }\n    }\n    return { response, status };\n}\n/** Polls the long-running operation. */\nexport async function pollOperation(inputs) {\n    const { poll, state, stateProxy, options, getOperationStatus, getResourceLocation, getOperationLocation, withOperationLocation, getPollingInterval, processResult, updateState, setDelay, isDone, } = inputs;\n    const { operationLocation } = state.config;\n    if (operationLocation !== undefined) {\n        const { response, status } = await pollOperationHelper({\n            poll,\n            getOperationStatus,\n            state,\n            stateProxy,\n            operationLocation,\n            getResourceLocation,\n            options,\n        });\n        if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) ||\n            (isDone === undefined && [\"succeeded\", \"canceled\"].includes(status))) {\n            stateProxy.setResult(state, buildResult({\n                response,\n                state,\n                processResult,\n            }));\n        }\n        else {\n            const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);\n            if (intervalInMs)\n                setDelay(intervalInMs);\n            const location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);\n            if (location !== undefined) {\n                const isUpdated = operationLocation !== location;\n                state.config.operationLocation = location;\n                withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);\n            }\n            else\n                withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n        }\n        updateState === null || updateState === void 0 ? void 0 : updateState(state, response);\n    }\n}\n//# sourceMappingURL=operation.js.map"]},"metadata":{},"sourceType":"module"}